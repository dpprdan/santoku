---
title: "santoku - a visual introduction"
author: "David Hugh-Jones"
date: "04/09/2019"
output: 
  revealjs::revealjs_presentation:
    md_extensions: +raw_html
    transition: none
    css: visual-intro-styles.css
    theme: serif
    reveal_options:
      slideNumber: true
      hash: true
      navigationMode: linear
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = FALSE, fig.height = 4, fig.width = 7)

library(santoku)

requireNamespace("png", quietly = TRUE)
requireNamespace("here", quietly = TRUE)
requireNamespace("scales", quietly = TRUE)
requireNamespace("plotrix", quietly = TRUE)

fish <- png::readPNG(here::here("man", "figures", "fish.png"))
fish <- fish[150:800, , ]
fish_alpha <- fish[, , 4]
fish_raster <- as.raster(fish)
fish_x <- ncol(fish)
fish_y <- nrow(fish)

suppressWarnings({
  # image is "upside down", so max and min are correct here
  fish_bottom <- apply(fish_alpha, 2, function (x) max(which(x > 0.8)))
  fish_top <- apply(fish_alpha, 2, function (x) min(which(x > 0.8)))
})
fish_bottom[is.infinite(fish_bottom)] <- NA
fish_top[is.infinite(fish_top)] <- NA
fish_top <- fish_y - fish_top
fish_bottom <- fish_y - fish_bottom

pts <- cbind(
        sample(nrow(fish), 1000, replace = TRUE),
        sample(ncol(fish), 1000, replace = TRUE)
      )
pts <- pts[fish_alpha[pts] > 0.9,] # matrix subsetting; points within the fish!
pts <- as.data.frame(pts)
names(pts) <- c("y", "x")
pts <- pts[, c("x", "y")]
pts$y <- fish_y - pts$y

pts <- rbind(pts, data.frame(x = 500, y = seq(200, 350, 10)))


palette(c("coral4", "darkgreen", "darkred", "darkgoldenrod3", "bisque4",
      "darkorange3", "darkkhaki", "salmon4"))
NA_col <- "grey"


plot_the_fish <- function (cols = "peachpuff4") {
  par(mar = c(2, 0, 0, 0))
  par(bg = "transparent")
  plot(c(1, fish_x), c(1, fish_y), type = 'n', axes = FALSE, xlab = "", 
        ylab = "")
  rasterImage(fish_raster, 1, 1, fish_x, fish_y)
  cols <- scales::alpha(cols, 0.75)
  points(pts$x, pts$y, col = cols, pch = 19, cex = 0.5)
  axis(1, seq(0, fish_x, 100), cex.axis = 0.7)
}


demo_chop <- function (breaks, labels = lbl_intervals(), extend = NULL, ...,
      lines = TRUE, swoosh = FALSE, lty = 1, show_labels = TRUE, cex_labels = 0.7) {
  chopped <- chop(pts$x, breaks, labels, extend, ...)
  if (is.numeric(breaks)) breaks <- brk_left(breaks)
  breaks <- breaks(pts$x, extend)
  
  breaks_r <- round(c(breaks[is.finite(breaks)]))
  breaks_r <- breaks_r[breaks_r > 0 & breaks_r <= fish_x]
  
  chopped_cols <- palette()[chopped]
  chopped_cols[is.na(chopped)] <- NA_col
  plot_the_fish(cols = chopped_cols)
  
  if (show_labels) {
    if (is.function(labels)) labels <- labels(breaks)
    label_breaks <- c(breaks)
    label_breaks[label_breaks == -Inf] <- 0
    label_breaks[label_breaks == Inf] <- fish_x
    midpoints <- (label_breaks[-1] + label_breaks[-length(label_breaks)])/2
    y <- if (any(diff(midpoints) < 150)) 20 else 50
    plotrix::boxed.labels(midpoints, rep_len(c(50, y), length(midpoints)), 
          labels, cex = cex_labels, bg = "white", border = FALSE, xpad = 1.1, ypad = 1.5)
  }
  
  if (lines) {
    segments(
          x0 = breaks_r,
          y0 = fish_bottom[breaks_r] - 30, 
          y1 = fish_top[breaks_r] + 30, 
          lwd = 1, lty = 1, col = "black"
        )
    
    if (swoosh) {
      left <- attr(breaks, "left")
      left <- left[is.finite(c(breaks)) & breaks > 0 & breaks <= fish_x]
      cols <- palette()[seq_len(nlevels(chopped))]
      if (! is.null(extend) && ! extend) cols <- c(NA_col, cols, NA_col)
      col <- ifelse(left, cols[-1], cols[-length(cols)])
  
      for (smooth in 1:5) {
        alpha <-  0.5 - 0.1 * smooth
        segments(
                x0 = breaks_r + 4 * smooth * ifelse(left, 1, -1),
                y0 = fish_bottom[breaks_r], 
                y1 = fish_top[breaks_r], 
                lwd = 4, col = scales::alpha(col, alpha)
              )
      }
    }
  }
}

```

## Santoku

A Japanese kitchen knife.

![chopping skills](https://media.giphy.com/media/ywSHsUF8TSdXHvDydU/giphy.gif)

## {santoku}

An R package for cutting data.

![santoku logo](../../man/figures/logo.png)


## Some data

```{r, echo = TRUE}
head(pts)
x <- pts$x
```

## Some data

```{r, echo = TRUE}
plot_the_fish()
```

## `chop()`

`chop()` is a replacement for base R's `cut()` function.

## `chop()`

```{r, echo = TRUE, eval = FALSE}
chop(x, c(300, 600, 900))
```

```{r}
demo_chop(c(300, 600, 900))
```

## `extend = FALSE`

```{r, echo = TRUE, eval = FALSE}
chop(x, c(300, 600, 900), extend = FALSE)
```

```{r}
demo_chop(c(300, 600, 900), extend = FALSE)
legend("bottomright", "NA", col = NA_col, pch = 19, bty = "n")
```

## Chopping by a single value


```{r, echo = TRUE, eval = FALSE}
chop(x, c(300, 500, 500, 800))
```

```{r}
demo_chop(c(300, 500, 500, 800))
arrows(x0 = 500, y0 =600, y1 = fish_top[500] + 40, lwd = 2, length = 0.1)
```

## `chop_width()`

Chops fixed-width intervals

```{r, echo = TRUE, eval = FALSE}
chop_width(x, width = 200)
```

```{r}
demo_chop(brk_width(width = 200))
```

## `chop_evenly()`

Chops `groups` equal-width intervals


```{r, echo = TRUE, eval = FALSE}
chop_evenly(x, groups = 5)
```

```{r}
demo_chop(brk_evenly(groups = 5))
```

## `chop_equally()`

Chops intervals with an equal *number of elements*

```{r, echo = TRUE, eval = FALSE}
chop_equally(x, groups = 5)
```

```{r}
demo_chop(brk_quantiles(1:4/5))
```

## `chop_n()`

Chops intervals with a *fixed* number of elements

```{r, echo = TRUE, eval = FALSE}
chop_n(x, 100)
```

```{r}
demo_chop(brk_n(100))
```


## Summary

Chop by:            | number of elements | width
--------------------|--------------------|-------------
Fixed size          | `chop_n()`         | `chop_width()`
Fixed no. of groups | `chop_equally()`   | `chop_evenly()`

## `chop_quantiles()`


```{r, echo = TRUE, eval = FALSE}
chop_quantiles(x, c(0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975)
```

```{r}
demo_chop(brk_quantiles(c(0.025, 0.05, 0.25, 0.5, 0.75, 0.95, 0.975)))
```

## `chop_mean_sd()`

```{r, echo = TRUE, eval = FALSE}
chop_mean_sd(x)
```

```{r}
demo_chop(brk_mean_sd())
```



## Quick tables

```{r, echo = TRUE}
tab(x, c(300, 600, 900))
tab_mean_sd(x)
```

## Changing labels

You need one more labels than breaks:

```{r, echo = TRUE, eval = FALSE}
chop(x, c(300, 600, 900), labels = LETTERS[1:4])
```

```{r}
demo_chop(c(300, 600, 900), labels = LETTERS[1:4], cex_labels = 1)
```


## Changing labels

Not sure how many intervals you will have? 

Use a `lbl_*` function.

```{r, echo = TRUE, eval = FALSE}
chop_width(x, 200, labels = lbl_LETTERS())
```


```{r}
demo_chop(brk_width(200), labels = lbl_LETTERS(), show_labels = TRUE, cex_labels = 1)
```

## Changing labels

Not sure how many intervals you will have? 

Use a `lbl_*` function.

```{r, echo = TRUE, eval = FALSE}
chop_width(x, 200, labels = lbl_roman("(%s)"))
```


```{r}
demo_chop(brk_width(200), labels = lbl_roman("(%s)"), show_labels = TRUE, cex_labels = 1)
```

## Changing labels

Not sure how many intervals you will have? 

Use a `lbl_*` function.

```{r, echo = TRUE, eval = FALSE}
chop_width(x, 200, labels = lbl_dash())
```


```{r}
demo_chop(brk_width(200), labels = lbl_dash(), show_labels = TRUE, cex_labels = 0.8)
```

## Left-closed and right-closed

Breaks are closed on the left by default.

```{r, echo = TRUE, eval = FALSE}
chop(x, c(200, 500, 800))
```

```{r}
demo_chop(c(200, 500, 800), swoosh = TRUE)
```


## Left-closed and right-closed

For right-closed breaks use `brk_right()`:

```{r, echo = TRUE, eval = FALSE}
chop(x, brk_right(c(200, 500, 800)))
```

```{r}
demo_chop(brk_right(c(200, 500, 800)), swoosh = TRUE)
```

## Happy chopping!

https://hughjonesd.github.io/santoku

```{r, echo = TRUE, eval = FALSE}
devtools::install_github("hughjonesd/santoku")
```

![Chopping](https://media.giphy.com/media/ceQ6oQNVCVbgY/giphy.gif)