% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/chop.R
\name{isolate_chop}
\alias{isolate_chop}
\title{Cut data into intervals, isolating common elements}
\usage{
isolate_chop(x, breaks, ..., n = NULL, prop = NULL, spike_labels = "{{{l}}}")
}
\arguments{
\item{x, breaks, ...}{Passed to \code{\link[=chop]{chop()}}.}

\item{n, prop}{Scalar. Provide either \code{n}, a number of values, or \code{prop},
a proportion of \code{length(x)}. Values of \code{x} which occur at least this
often will get their own singleton break.}

\item{spike_labels}{Glue string for spike labels. Use \code{"{l}"} for the spike
value.}
}
\value{
The result of \code{\link[=chop]{chop()}}, but with common values given their own factor levels.
}
\description{
Sometimes it's useful to separate out common elements of \code{x}.
\code{isolate_chop()} first chops \code{x}, then puts common elements of \code{x} ("spikes")
into separate categories.
}
\details{
Unlike \code{\link[=chop_spikes]{chop_spikes()}}, \code{isolate_chop()} doesn't break up
intervals which contain a spike. As a result, unlike other \verb{chop_*} functions,
\code{isolate_chop()} does not typically chop \code{x} into disjoint intervals. See
the examples.

If breaks are data-dependent, their labels may be misleading after common
elements have been removed. See the example below.

Levels of the result are ordered by the minimum element in each level. As
a result, if \code{drop = FALSE}, empty levels will be placed last.

This function is \ifelse{html}{\href{https://lifecycle.r-lib.org/articles/stages.html#experimental}{\figure{lifecycle-experimental.svg}{options: alt='[Experimental]'}}}{\strong{[Experimental]}}.
}
\examples{
x <- c(2, 3, 3, 3, 4)
isolate_chop(x, c(2, 4), n = 3)
isolate_chop(x, brk_width(2), prop = 0.5)

set.seed(42)
x <- runif(40, 0, 10)
x <- sample(x, 200, replace = TRUE)
# Compare:
table(isolate_chop(x, brk_width(2, 0), prop = 0.05))
# Versus:
tab_spikes(x, brk_width(2, 0), prop = 0.05)

# Misleading data-dependent breaks:
set.seed(42)
x <- rnorm(99)
x[1:10] <- x[1]
tab_quantiles(x, 1:2/3)
table(isolate_chop(x, brk_quantiles(1:2/3), prop = 0.1))
}
\seealso{
\code{\link[=chop_spikes]{chop_spikes()}} for a different approach.
}
