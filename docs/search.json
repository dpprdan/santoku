[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2019 David Hugh-Jones Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/TODO.html","id":null,"dir":"","previous_headings":"","what":"TODO","title":"TODO","text":"tests left close_end arguments tests brk_default brk_width() needs tests match guarantees documentation ditto brk_evenly() now uses implementation guarantee exactly intervals intervals systematic tests brk_* functions problem moment vec_cast() highly unreliable never know particular class accept Inf. infinity class fine, go existing breaks object underlying class? NB requires new way create labels, kinda sucks….","code":""},{"path":"/TODO.html","id":"thoughts-on-errors","dir":"","previous_headings":"","what":"Thoughts on errors","title":"TODO","text":"Exception: x wrong class type. e.g. brk_manual() extend set. cases, e.g. brk_evenly() don’t need make guarantee.","code":""},{"path":"/TODO.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"TODO","text":"alternative x non-numeric. makes surprise rarer, rare surprises can worse… adds complexity since functions generic. another alternative: chop sets left = FALSE non-numeric x. Probably better. drop default ! isTRUE(extend) .e. FALSE extend = TRUE?","code":""},{"path":"/TODO.html","id":"questions-with-a-provisional-answer","dir":"","previous_headings":"","what":"Questions with a (provisional) answer","title":"TODO","text":", labels = NULL integer codes though. sense , unless someone asks. Oh, someone just ask; generally though. . don’t want people set position, distinguish initial arguments. Current answer: fuck ’em. (NB: just kidding. huge tidyverse fan.) provide kiru(). REPL, people can just use kiru() load santoku first. load santoku second, ’ll use tidyr::chop(), reading documentation, suspect rare. programming, people probably used fully qualified name anyway. think default “necessary” (extend = NULL); always extend Inf, -Inf break labels data-dependent Tension wanting something predictable new data, vs. something readable tab_*. E.g. surely return labels , b, c. means aren’t always extending. lets people e.g. chop(rnorm(100), -2:2, LETTERS) might hide errors overall ’m maybe label functions access x? informed breaks got extended? breaks object know extend labels? current solution: labels get extend think better: breaks objects include suggested labels user can override. way always info necessary. choosing break numbers (may actual values, e.g quantiles std errs 0) formatting numbers, dashes, set notation etc maybe brk_* functions always return break numbers; labels decide format ? warning? currently error throw error cases e.g. brk_quantiles, brk_width, data may work well e.g. NA. empty set breaks?","code":"tab_size(1:9, 3, lbl_seq())"},{"path":"/TODO.html","id":"possible-interfaces","dir":"","previous_headings":"","what":"Possible interfaces","title":"TODO","text":"hist_xxx functions histograms/barplots? (treat singletons?) grp_xxx group_by? Hmmm… New label interface replace lbl_sequence: lbl_style(\"1.\"), lbl_style(\"()\"), lbl_style(\"\") etc.? Still wonder, drop extend adds complexity just () extend() new breaks functions?","code":""},{"path":"/TODO.html","id":"other-ideas","dir":"","previous_headings":"","what":"Other ideas","title":"TODO","text":"Speedup categorize checking left intervals, add 1 past interval [: actually fewer checks end…] Speedup using pointers? hmm, magic…","code":""},{"path":"/articles/santoku.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to santoku","text":"Santoku package cutting data intervals. provides replacement base R’s cut() function.","code":""},{"path":"/articles/santoku.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to santoku","text":"install santoku, run:","code":"install.packages(\"santoku\")"},{"path":"/articles/santoku.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic usage","title":"Introduction to santoku","text":"Use chop() like cut() cut data : chop() returns factor. data beyond limits breaks, extended automatically: chop single number separate category, put number twice breaks: quickly produce table chopped data, use tab():","code":"library(santoku) x <- runif(10, 0, 10) (chopped <- chop(x, breaks = 0:10)) #>  [1] [4, 5)  [8, 9)  [3, 4)  [4, 5)  [7, 8)  [9, 10) [6, 7)  [8, 9)  [1, 2)  #> [10] [4, 5)  #> Levels: [1, 2) [3, 4) [4, 5) [6, 7) [7, 8) [8, 9) [9, 10) data.frame(x, chopped) #>           x chopped #> 1  4.978305  [4, 5) #> 2  8.969989  [8, 9) #> 3  3.391823  [3, 4) #> 4  4.676785  [4, 5) #> 5  7.057042  [7, 8) #> 6  9.707687 [9, 10) #> 7  6.713807  [6, 7) #> 8  8.376589  [8, 9) #> 9  1.086165  [1, 2) #> 10 4.495479  [4, 5) chopped <- chop(x, breaks = 3:7) data.frame(x, chopped) #>           x    chopped #> 1  4.978305     [4, 5) #> 2  8.969989 [7, 9.708] #> 3  3.391823     [3, 4) #> 4  4.676785     [4, 5) #> 5  7.057042 [7, 9.708] #> 6  9.707687 [7, 9.708] #> 7  6.713807     [6, 7) #> 8  8.376589 [7, 9.708] #> 9  1.086165 [1.086, 3) #> 10 4.495479     [4, 5) x_fives <- x x_fives[1:5] <- 5 chopped <- chop(x_fives, c(2, 5, 5, 8)) data.frame(x_fives, chopped) #>     x_fives    chopped #> 1  5.000000        {5} #> 2  5.000000        {5} #> 3  5.000000        {5} #> 4  5.000000        {5} #> 5  5.000000        {5} #> 6  9.707687 [8, 9.708] #> 7  6.713807     (5, 8) #> 8  8.376589 [8, 9.708] #> 9  1.086165 [1.086, 2) #> 10 4.495479     [2, 5) tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3"},{"path":"/articles/santoku.html","id":"more-ways-to-chop","dir":"Articles","previous_headings":"","what":"More ways to chop","title":"Introduction to santoku","text":"chop fixed-width intervals, starting minimum value, use chop_width(): chop exactly intervals fixed-intervals, use chop_evenly(): chop groups fixed number members, use chop_n(): chop fixed number equal-sized groups, use chop_equally(): chop data quantiles, use chop_quantiles(): chop data standard deviations around mean, use chop_mean_sd(): chop data attractive intervals, use chop_pretty(). selects intervals multiple 2, 5 10. ’s useful producing bar plots. tab_n(), tab_width(), friends act similarly tab(), calling related chop_* function table() result. can chop dates :","code":"chopped <- chop_width(x, 2) data.frame(x, chopped) #>           x        chopped #> 1  4.978305 [3.086, 5.086) #> 2  8.969989 [7.086, 9.086) #> 3  3.391823 [3.086, 5.086) #> 4  4.676785 [3.086, 5.086) #> 5  7.057042 [5.086, 7.086) #> 6  9.707687 [9.086, 11.09) #> 7  6.713807 [5.086, 7.086) #> 8  8.376589 [7.086, 9.086) #> 9  1.086165 [1.086, 3.086) #> 10 4.495479 [3.086, 5.086) chopped <- chop_evenly(x, intervals = 3) data.frame(x, chopped) #>           x        chopped #> 1  4.978305  [3.96, 6.834) #> 2  8.969989 [6.834, 9.708] #> 3  3.391823  [1.086, 3.96) #> 4  4.676785  [3.96, 6.834) #> 5  7.057042 [6.834, 9.708] #> 6  9.707687 [6.834, 9.708] #> 7  6.713807  [3.96, 6.834) #> 8  8.376589 [6.834, 9.708] #> 9  1.086165  [1.086, 3.96) #> 10 4.495479  [3.96, 6.834) chopped <- chop_n(x, 4) table(chopped) #> chopped #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 chopped <- chop_equally(x, groups = 5) table(chopped) #> chopped #> [1.086, 4.275) [4.275, 4.858) [4.858, 6.851) [6.851, 8.495) [8.495, 9.708]  #>              2              2              2              2              2 chopped <- chop_quantiles(x, c(0.25, 0.5, 0.75)) data.frame(x, chopped) #>           x     chopped #> 1  4.978305  [25%, 50%) #> 2  8.969989 (75%, 100%] #> 3  3.391823   [0%, 25%) #> 4  4.676785  [25%, 50%) #> 5  7.057042  [50%, 75%] #> 6  9.707687 (75%, 100%] #> 7  6.713807  [50%, 75%] #> 8  8.376589 (75%, 100%] #> 9  1.086165   [0%, 25%) #> 10 4.495479   [0%, 25%) chopped <- chop_mean_sd(x) data.frame(x, chopped) #>           x        chopped #> 1  4.978305  [-1 sd, 0 sd) #> 2  8.969989   [1 sd, 2 sd) #> 3  3.391823  [-1 sd, 0 sd) #> 4  4.676785  [-1 sd, 0 sd) #> 5  7.057042   [0 sd, 1 sd) #> 6  9.707687   [1 sd, 2 sd) #> 7  6.713807   [0 sd, 1 sd) #> 8  8.376589   [0 sd, 1 sd) #> 9  1.086165 [-2 sd, -1 sd) #> 10 4.495479  [-1 sd, 0 sd) chopped <- chop_pretty(x) data.frame(x, chopped) #>           x chopped #> 1  4.978305  [4, 6) #> 2  8.969989 [8, 10) #> 3  3.391823  [2, 4) #> 4  4.676785  [4, 6) #> 5  7.057042  [6, 8) #> 6  9.707687 [8, 10) #> 7  6.713807  [6, 8) #> 8  8.376589 [8, 10) #> 9  1.086165  [0, 2) #> 10 4.495479  [4, 6) tab_n(x, 4) #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 tab_width(x, 2) #> [1.086, 3.086) [3.086, 5.086) [5.086, 7.086) [7.086, 9.086) [9.086, 11.09)  #>              1              4              2              2              1 tab_evenly(x, 5) #>  [1.086, 2.81)  [2.81, 4.535) [4.535, 6.259) [6.259, 7.983) [7.983, 9.708]  #>              1              2              2              2              3 tab_mean_sd(x) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              1              4              3              2 library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union y2k <- as.Date(\"2000-01-01\") + 0:365 months <- chop_width(y2k, months(1)) table(months) #> months #> [2000-01-01, 2000-02-01) [2000-02-01, 2000-03-01) [2000-03-01, 2000-04-01)  #>                       31                       29                       31  #> [2000-04-01, 2000-05-01) [2000-05-01, 2000-06-01) [2000-06-01, 2000-07-01)  #>                       30                       31                       30  #> [2000-07-01, 2000-08-01) [2000-08-01, 2000-09-01) [2000-09-01, 2000-10-01)  #>                       31                       31                       30  #> [2000-10-01, 2000-11-01) [2000-11-01, 2000-12-01) [2000-12-01, 2001-01-01)  #>                       31                       30                       31"},{"path":"/articles/santoku.html","id":"advanced-usage","dir":"Articles","previous_headings":"","what":"Advanced usage","title":"Introduction to santoku","text":"can change factor labels labels argument: need many labels intervals - one fewer length(breaks) data doesn’t extend beyond breaks, one length(breaks) . label intervals dash, use lbl_dash(): label integer data, use lbl_discrete(). uses informative right endpoints: can customize first last labels: label intervals order use lbl_seq(): can use numerals even roman numerals: labelling functions include: lbl_endpoints() - use left endpoints labels lbl_midpoints() - use interval midpoints labels lbl_manual() - specify labels manually lbl_glue() - specify labels flexibly glue package default, chop() extends breaks necessary. don’t want , set extend = FALSE: Data outside range breaks become NA. default, intervals closed left, .e. include left endpoints. want right-closed intervals, set left = FALSE: want close last interval, set close_end = TRUE:","code":"chopped <- chop(x, c(2, 5, 8), labels = c(\"Lowest\", \"Low\", \"Higher\", \"Highest\")) data.frame(x, chopped) #>           x chopped #> 1  4.978305     Low #> 2  8.969989 Highest #> 3  3.391823     Low #> 4  4.676785     Low #> 5  7.057042  Higher #> 6  9.707687 Highest #> 7  6.713807  Higher #> 8  8.376589 Highest #> 9  1.086165  Lowest #> 10 4.495479     Low chopped <- chop(x, c(2, 5, 8), labels = lbl_dash()) data.frame(x, chopped) #>           x chopped #> 1  4.978305     2—5 #> 2  8.969989 8—9.708 #> 3  3.391823     2—5 #> 4  4.676785     2—5 #> 5  7.057042     5—8 #> 6  9.707687 8—9.708 #> 7  6.713807     5—8 #> 8  8.376589 8—9.708 #> 9  1.086165 1.086—2 #> 10 4.495479     2—5 chopped  <- chop(1:10, c(2, 5, 8), labels = lbl_discrete()) chopped2 <- chop(1:10, c(2, 5, 8), labels = lbl_dash()) data.frame(x = 1:10, lbl_discrete = chopped, lbl_dash = chopped2) #>     x lbl_discrete lbl_dash #> 1   1            1      1—2 #> 2   2          2—4      2—5 #> 3   3          2—4      2—5 #> 4   4          2—4      2—5 #> 5   5          5—7      5—8 #> 6   6          5—7      5—8 #> 7   7          5—7      5—8 #> 8   8         8—10     8—10 #> 9   9         8—10     8—10 #> 10 10         8—10     8—10 chopped <- chop(x, c(2, 5, 8), labels = lbl_dash(first = \"< 2\", last = \"8+\")) data.frame(x, chopped) #>           x chopped #> 1  4.978305     2—5 #> 2  8.969989      8+ #> 3  3.391823     2—5 #> 4  4.676785     2—5 #> 5  7.057042     5—8 #> 6  9.707687      8+ #> 7  6.713807     5—8 #> 8  8.376589      8+ #> 9  1.086165     < 2 #> 10 4.495479     2—5 chopped <- chop(x, c(2, 5, 8), labels = lbl_seq()) data.frame(x, chopped) #>           x chopped #> 1  4.978305       b #> 2  8.969989       d #> 3  3.391823       b #> 4  4.676785       b #> 5  7.057042       c #> 6  9.707687       d #> 7  6.713807       c #> 8  8.376589       d #> 9  1.086165       a #> 10 4.495479       b chop(x, c(2, 5, 8), labels = lbl_seq(\"(1)\")) #>  [1] (2) (4) (2) (2) (3) (4) (3) (4) (1) (2) #> Levels: (1) (2) (3) (4) chop(x, c(2, 5, 8), labels = lbl_seq(\"i.\")) #>  [1] ii.  iv.  ii.  ii.  iii. iv.  iii. iv.  i.   ii.  #> Levels: i. ii. iii. iv. chopped <- chop(x, c(3, 5, 7), extend = FALSE) data.frame(x, chopped) #>           x chopped #> 1  4.978305  [3, 5) #> 2  8.969989    <NA> #> 3  3.391823  [3, 5) #> 4  4.676785  [3, 5) #> 5  7.057042    <NA> #> 6  9.707687    <NA> #> 7  6.713807  [5, 7) #> 8  8.376589    <NA> #> 9  1.086165    <NA> #> 10 4.495479  [3, 5) y <- 1:5 data.frame(         y = y,          left_closed = chop(y, 1:5),          right_closed = chop(y, 1:5, left = FALSE)       ) #>   y left_closed right_closed #> 1 1      [1, 2)          {1} #> 2 2      [2, 3)       (1, 2] #> 3 3      [3, 4)       (2, 3] #> 4 4      [4, 5)       (3, 4] #> 5 5         {5}       (4, 5] data.frame(   y = y,   rightmost_open = chop(y, 1:5),   rightmost_closed   = chop(y, 1:5, close_end = TRUE) ) #>   y rightmost_open rightmost_closed #> 1 1         [1, 2)           [1, 2) #> 2 2         [2, 3)           [2, 3) #> 3 3         [3, 4)           [3, 4) #> 4 4         [4, 5)           [4, 5] #> 5 5            {5}           [4, 5]"},{"path":"/articles/website-articles/performance.html","id":"speed","dir":"Articles > Website-articles","previous_headings":"","what":"Speed","title":"Performance","text":"core santoku written C++. reasonably fast:","code":"packageVersion(\"santoku\") #> [1] '0.8.0' set.seed(27101975)  mb <- bench::mark(         santoku::chop(rnorm(1e5), -2:2),         base::cut(rnorm(1e5), -2:2),         Hmisc::cut2(rnorm(1e5), -2:2),         min_iterations = 100,         check = FALSE       ) mb #> # A tibble: 3 × 6 #>   expression                             min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                        <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(rnorm(1e+05), -2:2)   30.8ms   38ms      24.8   14.86MB    16.5  #> 2 base::cut(rnorm(1e+05), -2:2)       17.3ms 20.5ms      45.6    3.49MB     6.81 #> 3 Hmisc::cut2(rnorm(1e+05), -2:2)     52.6ms 62.9ms      14.8   88.41MB    16.7 autoplot(mb, type = \"violin\") #> Loading required namespace: tidyr"},{"path":"/articles/website-articles/performance.html","id":"dates","dir":"Articles > Website-articles","previous_headings":"","what":"Dates","title":"Performance","text":"","code":"dates <- sample(as.Date(\"2000-01-01\") + 0:364, 1e5, replace = TRUE) break_dates <- as.Date(\"2000-01-01\") + c(60, 120, 180)  mb_dates <- bench::mark(               santoku::chop(dates, break_dates),               base::cut(dates, break_dates),               Hmisc::cut2(dates, break_dates),               min_iterations = 100,               check = FALSE             )  mb_dates #> # A tibble: 3 × 6 #>   expression                             min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                        <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(dates, break_dates)  20.98ms 24.8ms      38.2    10.6MB    16.4  #> 2 base::cut(dates, break_dates)       9.71ms 13.5ms      72.6     3.9MB     7.18 #> 3 Hmisc::cut2(dates, break_dates)    22.12ms 28.4ms      32.5    15.3MB    14.6 autoplot(mb_dates, type = \"violin\")"},{"path":"/articles/website-articles/performance.html","id":"cutting-characters-pure-r-implementation","dir":"Articles > Website-articles","previous_headings":"","what":"Cutting characters (pure R implementation)","title":"Performance","text":"","code":"oo <- options(santoku.warn_character = FALSE)   lipsum <- stringi::stri_rand_lipsum(100)  mb_pure_r <- bench::mark(                santoku::chop(lipsum, letters),                santoku::chop(seq(1, 26, length = 100), 1:26),                min_iterations = 100,                check = FALSE              )  mb_pure_r #> # A tibble: 2 × 6 #>   expression                                         min   median `itr/sec` #>   <bch:expr>                                    <bch:tm> <bch:tm>     <dbl> #> 1 santoku::chop(lipsum, letters)                  3.17ms    3.7ms      253. #> 2 santoku::chop(seq(1, 26, length = 100), 1:26)    2.1ms   2.91ms      312. #> # … with 2 more variables: mem_alloc <bch:byt>, `gc/sec` <dbl>  options(oo) autoplot(mb_pure_r, type = \"violin\")"},{"path":"/articles/website-articles/performance.html","id":"many-breaks","dir":"Articles > Website-articles","previous_headings":"","what":"Many breaks","title":"Performance","text":"","code":"many_breaks <- seq(-2, 2, 0.001)  mb_breaks <- bench::mark(         santoku::chop(rnorm(1e4), many_breaks),         base::cut(rnorm(1e4), many_breaks),         Hmisc::cut2(rnorm(1e4), many_breaks),         min_iterations = 100,         check = FALSE       )  mb_breaks #> # A tibble: 3 × 6 #>   expression                                    min   median `itr/sec` mem_alloc #>   <bch:expr>                               <bch:tm> <bch:tm>     <dbl> <bch:byt> #> 1 santoku::chop(rnorm(10000), many_breaks)   44.3ms   56.1ms      11.4    5.08MB #> 2 base::cut(rnorm(10000), many_breaks)       12.6ms   20.2ms      34.0    1.54MB #> 3 Hmisc::cut2(rnorm(10000), many_breaks)     34.6ms   37.7ms      25.4     6.2MB #> # … with 1 more variable: `gc/sec` <dbl> autoplot(mb_breaks, type = \"violin\")"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Hugh-Jones. Author, maintainer. Daniel Possenriede. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hugh-Jones D (2022). santoku: Versatile Cutting Tool. https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/.","code":"@Manual{,   title = {santoku: A Versatile Cutting Tool},   author = {David Hugh-Jones},   year = {2022},   note = {https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/}, }"},{"path":"/index.html","id":"santoku-","dir":"","previous_headings":"","what":"A Versatile Cutting Tool","title":"A Versatile Cutting Tool","text":"santoku versatile cutting tool R. provides chop(), replacement base::cut().","code":""},{"path":"/index.html","id":"advantages","dir":"","previous_headings":"","what":"Advantages","title":"A Versatile Cutting Tool","text":"advantages santoku: default, chop() always covers whole range data, won’t get unexpected NA values. chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. Flexible labelling, including easy ways label intervals numerals letters. Convenience functions creating quantile intervals, evenly-spaced intervals equal-sized groups. Convenience functions quickly tabulating chopped data. advantages make santoku especially useful exploratory analysis, may know range data advance.","code":""},{"path":"/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"A Versatile Cutting Tool","text":"chop returns factor: Include number twice match exactly: Customize output lbl_* functions: Chop fixed-width intervals: fixed-size groups: Chop dates calendar month, tabulate: information, see vignette.","code":"library(santoku) chop(1:8, c(3, 5, 7)) #> [1] [1, 3) [1, 3) [3, 5) [3, 5) [5, 7) [5, 7) [7, 8] [7, 8] #> Levels: [1, 3) [3, 5) [5, 7) [7, 8] chop(1:8, c(3, 5, 5, 7)) #> [1] [1, 3) [1, 3) [3, 5) [3, 5) {5}    (5, 7) [7, 8] [7, 8] #> Levels: [1, 3) [3, 5) {5} (5, 7) [7, 8] chop(1:8, c(3, 5, 7), labels = lbl_dash()) #> [1] 1—3 1—3 3—5 3—5 5—7 5—7 7—8 7—8 #> Levels: 1—3 3—5 5—7 7—8 chop_width(runif(10), 0.1) #>  [1] [0.8278, 0.9278)  [0.8278, 0.9278)  [0.8278, 0.9278)  [0.3278, 0.4278)  #>  [5] [0.7278, 0.8278)  [0.2278, 0.3278)  [0.9278, 1.028)   [0.02781, 0.1278) #>  [9] [0.9278, 1.028)   [0.02781, 0.1278) #> 6 Levels: [0.02781, 0.1278) [0.2278, 0.3278) ... [0.9278, 1.028) chop_n(1:10, 5) #>  [1] [1, 6)  [1, 6)  [1, 6)  [1, 6)  [1, 6)  [6, 10] [6, 10] [6, 10] [6, 10] #> [10] [6, 10] #> Levels: [1, 6) [6, 10] library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union  tab_width(as.Date(\"2021-12-31\") + 1:90, months(1),              labels = lbl_discrete(fmt = \"%d %b\")           ) #> 01 Jan—31 Jan 01 Feb—28 Feb 01 Mar—31 Mar  #>            31            28            31"},{"path":"/reference/breaks-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class representing a set of intervals — breaks-class","title":"Class representing a set of intervals — breaks-class","text":"Class representing set intervals","code":""},{"path":"/reference/breaks-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class representing a set of intervals — breaks-class","text":"","code":"# S3 method for breaks format(x, ...)  # S3 method for breaks print(x, ...)  is.breaks(x, ...)"},{"path":"/reference/breaks-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class representing a set of intervals — breaks-class","text":"x breaks object ... Unused","code":""},{"path":[]},{"path":"/reference/brk-left-right.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"brk_left(breaks)  brk_right(breaks)"},{"path":"/reference/brk-left-right.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left- or right-closed breaks — brk-left-right","text":"breaks numeric vector.","code":""},{"path":"/reference/brk-left-right.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left- or right-closed breaks — brk-left-right","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk-left-right.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Left- or right-closed breaks — brk-left-right","text":"functions \"questioning\" stage clash left argument chop() friends. functions override left argument chop().","code":""},{"path":"/reference/brk-left-right.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"chop(5:7, brk_left(5:7)) #> Warning: `brk_left()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_warnings()` to see where this warning was generated. #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}  chop(5:7, brk_right(5:7)) #> Warning: `brk_right()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_warnings()` to see where this warning was generated. #> Warning: `left` argument to `brk_right()` ignored #> [1] {5}    (5, 6] (6, 7] #> Levels: {5} (5, 6] (6, 7]  chop(5:7, brk_left(5:7)) #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}"},{"path":"/reference/brk_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a standard set of breaks — brk_default","title":"Create a standard set of breaks — brk_default","text":"Create standard set breaks","code":""},{"path":"/reference/brk_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a standard set of breaks — brk_default","text":"","code":"brk_default(breaks)"},{"path":"/reference/brk_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a standard set of breaks — brk_default","text":"breaks numeric vector.","code":""},{"path":"/reference/brk_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a standard set of breaks — brk_default","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk_default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a standard set of breaks — brk_default","text":"","code":"chop(1:10, c(2, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10] chop(1:10, brk_default(c(2, 5, 8))) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10]"},{"path":"/reference/brk_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a breaks object manually — brk_manual","title":"Create a breaks object manually — brk_manual","text":"Create breaks object manually","code":""},{"path":"/reference/brk_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a breaks object manually — brk_manual","text":"","code":"brk_manual(breaks, left_vec)"},{"path":"/reference/brk_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a breaks object manually — brk_manual","text":"breaks vector, must sorted. left_vec logical vector, length breaks. Specifies whether break left-closed right-closed.","code":""},{"path":"/reference/brk_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a breaks object manually — brk_manual","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk_manual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a breaks object manually — brk_manual","text":"breaks must closed exactly one side, like ..., x) [x, ... (left-closed) ..., x) [x, ... (right-closed). example, breaks = 1:3 left = c(TRUE, FALSE, TRUE), resulting intervals Singleton breaks created repeating number breaks. Singletons must closed sides, repeated number indices , +1, left[] must TRUE left[+1] must FALSE.","code":"T        F       T [ 1,  2 ] ( 2, 3 )"},{"path":"/reference/brk_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a breaks object manually — brk_manual","text":"","code":"lbrks <- brk_manual(1:3, rep(TRUE, 3)) chop(1:3, lbrks, extend = FALSE) #> [1] [1, 2) [2, 3) <NA>   #> Levels: [1, 2) [2, 3)  rbrks <- brk_manual(1:3, rep(FALSE, 3)) chop(1:3, rbrks, extend = FALSE) #> [1] <NA>   (1, 2] (2, 3] #> Levels: (1, 2] (2, 3]  brks_singleton <- brk_manual(       c(1,    2,    2,     3),       c(TRUE, TRUE, FALSE, TRUE))  chop(1:3, brks_singleton, extend = FALSE) #> [1] [1, 2) {2}    <NA>   #> Levels: [1, 2) {2}"},{"path":"/reference/brk_width-for-datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"brk_width() can used time interval classes base R lubridate package.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"# S3 method for Duration brk_width(width, start)"},{"path":"/reference/brk_width-for-datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width scalar difftime, Period Duration object. start scalar class Date POSIXct. Can omitted.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width Period, lubridate::add_with_rollback() used calculate widths. can useful e.g. calendar months.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"if (requireNamespace(\"lubridate\")) {   year2001 <- as.Date(\"2001-01-01\") + 0:364   tab_width(year2001, months(1),         labels = lbl_discrete(\" to \", fmt = \"%e %b %y\")) } #>  1 Jan 01 to 31 Jan 01  1 Feb 01 to 28 Feb 01  1 Mar 01 to 31 Mar 01  #>                     31                     28                     31  #>  1 Apr 01 to 30 Apr 01  1 May 01 to 31 May 01  1 Jun 01 to 30 Jun 01  #>                     30                     31                     30  #>  1 Jul 01 to 31 Jul 01  1 Aug 01 to 31 Aug 01  1 Sep 01 to 30 Sep 01  #>                     31                     31                     30  #>  1 Oct 01 to 31 Oct 01  1 Nov 01 to 30 Nov 01  1 Dec 01 to 31 Dec 01  #>                     31                     30                     31"},{"path":"/reference/chop.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut data into intervals — chop","title":"Cut data into intervals — chop","text":"chop() cuts x intervals. returns factor length x, representing interval contains element x. kiru() alias chop. tab() calls chop() returns contingency table() result.","code":""},{"path":"/reference/chop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut data into intervals — chop","text":"","code":"chop(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = FALSE,   drop = TRUE )  kiru(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = FALSE,   drop = TRUE )  tab(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = FALSE,   drop = TRUE )"},{"path":"/reference/chop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut data into intervals — chop","text":"x vector. breaks numeric vector cut-points function create cut-points x. labels character vector labels function create labels. extend Logical. Extend breaks +/-Inf? left Logical. Left-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) drop Logical. Drop unused levels result?","code":""},{"path":"/reference/chop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut data into intervals — chop","text":"chop() returns factor length x, representing intervals containing value x. tab() returns contingency table().","code":""},{"path":"/reference/chop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut data into intervals — chop","text":"x may numeric vector, generally, vector can compared < == (see Ops). particular Date date-time objects supported. Character vectors supported warning.","code":""},{"path":"/reference/chop.html","id":"breaks","dir":"Reference","previous_headings":"","what":"Breaks","title":"Cut data into intervals — chop","text":"breaks may vector function. vector, breaks gives break endpoints. Repeated values create singleton intervals. example breaks = c(1, 3, 3, 5) creates 3 intervals: [1, 3), {3} (3, 5]. breaks function, called x, extend, left close_end arguments, return object class breaks. Use brk_* functions create variety data-dependent breaks.","code":""},{"path":"/reference/chop.html","id":"options-for-breaks","dir":"Reference","previous_headings":"","what":"Options for breaks","title":"Cut data into intervals — chop","text":"default, left-closed intervals created. left FALSE, right- closed intervals created. close_end TRUE end break closed ends, ensuring values x min(breaks) <= x <= max(breaks) included default intervals. Using mathematical set notation: left TRUE close_end TRUE, breaks look like [x1, x2), [x2, x3) ... [x_n-1, x_n]. left FALSE close_end TRUE, breaks look like [x1, x2], (x2, x3] ... (x_n-1, x_n]. left TRUE close_end FALSE, breaks look like ...[x1, x2) .... left FALSE close_end FALSE, breaks look like ...(x1, x2] ....","code":""},{"path":"/reference/chop.html","id":"extending-intervals","dir":"Reference","previous_headings":"","what":"Extending intervals","title":"Cut data into intervals — chop","text":"extend TRUE, intervals extended [-Inf, min(breaks)) (max(breaks), Inf]. extend NULL (default), intervals extended [min(x), min(breaks)) (max(breaks), max(x)], necessary -- .e. min(x) < min(breaks) max(x) > max(breaks) respectively. Extending intervals, either extend = NULL extend = TRUE, always leaves central, non-extended intervals unchanged. particular, close_end applies central intervals, extended ones. example, breaks = c(1, 3, 5) close_end = TRUE, resulting breaks [1, 3), [3, 5] extend = TRUE result [-Inf, 1), [1, 3), [3, 5], (5, Inf]","code":""},{"path":"/reference/chop.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Cut data into intervals — chop","text":"labels may character vector. length number intervals. Alternatively, use lbl_* function lbl_seq(). labels NULL, integer codes returned instead factor.","code":""},{"path":"/reference/chop.html","id":"miscellaneous","dir":"Reference","previous_headings":"","what":"Miscellaneous","title":"Cut data into intervals — chop","text":"NA values x, values outside extended endpoints, return NA. kiru() synonym chop(). load {tidyr}, can use avoid confusion tidyr::chop(). Note chop(), like R, uses binary arithmetic. Thus, numbers may exactly equal think . example .","code":""},{"path":[]},{"path":"/reference/chop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut data into intervals — chop","text":"","code":"chop(1:3, 2) #> [1] [1, 2) [2, 3] [2, 3] #> Levels: [1, 2) [2, 3]  chop(1:10, c(2, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10]  chop(1:10, c(2, 5, 8), extend = FALSE) #>  [1] <NA>   [2, 5) [2, 5) [2, 5) [5, 8) [5, 8) [5, 8) <NA>   <NA>   <NA>   #> Levels: [2, 5) [5, 8)  chop(1:10, c(2, 5, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]  chop(1:10, c(2, 5, 8), left = FALSE) #>  [1] [1, 2]  [1, 2]  (2, 5]  (2, 5]  (2, 5]  (5, 8]  (5, 8]  (5, 8]  (8, 10] #> [10] (8, 10] #> Levels: [1, 2] (2, 5] (5, 8] (8, 10]  chop(1:10, c(2, 5, 8), close_end = TRUE) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8]  [5, 8]  [5, 8]  [5, 8]  (8, 10] #> [10] (8, 10] #> Levels: [1, 2) [2, 5) [5, 8] (8, 10]  chop(1:10, brk_quantiles(c(0.25, 0.75))) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 75%)  [25%, 75%)  [25%, 75%)  #>  [7] [25%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 75%) [75%, 100%]  chop(1:10, c(2, 5, 8), labels = lbl_dash()) #>  [1] 1—2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: 1—2 2—5 5—8 8—10  # floating point inaccuracy: chop(0.3/3, c(0, 0.1, 0.1, 1), labels = c(\"< 0.1\", \"0.1\", \"> 0.1\")) #> [1] < 0.1 #> Levels: < 0.1  tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3"},{"path":"/reference/chop_equally.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop equal-sized groups — chop_equally","title":"Chop equal-sized groups — chop_equally","text":"chop_equally() chops x groups equal number elements.","code":""},{"path":"/reference/chop_equally.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop equal-sized groups — chop_equally","text":"","code":"chop_equally(   x,   groups,   ...,   labels = lbl_intervals(raw = TRUE),   left = is.numeric(x),   close_end = TRUE )  brk_equally(groups)  tab_equally(x, groups, ..., left = is.numeric(x), close_end = TRUE)"},{"path":"/reference/chop_equally.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop equal-sized groups — chop_equally","text":"x vector. groups Number groups. ... Passed chop(). labels character vector labels function create labels. left Logical. Left-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/chop_equally.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop equal-sized groups — chop_equally","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":[]},{"path":"/reference/chop_equally.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop equal-sized groups — chop_equally","text":"","code":"chop_equally(1:10, 5) #>  [1] [1, 2.8)   [1, 2.8)   [2.8, 4.6) [2.8, 4.6) [4.6, 6.4) [4.6, 6.4) #>  [7] [6.4, 8.2) [6.4, 8.2) [8.2, 10]  [8.2, 10]  #> Levels: [1, 2.8) [2.8, 4.6) [4.6, 6.4) [6.4, 8.2) [8.2, 10]"},{"path":"/reference/chop_evenly.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into equal-width intervals — chop_evenly","title":"Chop into equal-width intervals — chop_evenly","text":"chop_evenly() chops x intervals intervals equal width.","code":""},{"path":"/reference/chop_evenly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into equal-width intervals — chop_evenly","text":"","code":"chop_evenly(x, intervals, ..., close_end = TRUE)  brk_evenly(intervals)  tab_evenly(x, intervals, ..., close_end = TRUE)"},{"path":"/reference/chop_evenly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into equal-width intervals — chop_evenly","text":"x vector. intervals Integer: number intervals create. ... Passed chop(). close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/chop_evenly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into equal-width intervals — chop_evenly","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_evenly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into equal-width intervals — chop_evenly","text":"chop_evenly() sets close_end = TRUE default.","code":""},{"path":[]},{"path":"/reference/chop_evenly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into equal-width intervals — chop_evenly","text":"","code":"chop_evenly(0:10, 5) #>  [1] [0, 2)  [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] #> [10] [8, 10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]"},{"path":"/reference/chop_mean_sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by standard deviations — chop_mean_sd","title":"Chop by standard deviations — chop_mean_sd","text":"Intervals measured standard deviations either side mean.","code":""},{"path":"/reference/chop_mean_sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(x, sds = 1:3, ..., sd = deprecated())  brk_mean_sd(sds = 1:3, sd = deprecated())  tab_mean_sd(x, sds = 1:3, ...)"},{"path":"/reference/chop_mean_sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by standard deviations — chop_mean_sd","text":"x vector. sds Positive numeric vector standard deviations. ... Passed chop(). sd","code":""},{"path":"/reference/chop_mean_sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by standard deviations — chop_mean_sd","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_mean_sd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop by standard deviations — chop_mean_sd","text":"version 0.7.0, functions changed specifying sds vector. chop 1, 2 3 standard deviations around mean, write chop_mean_sd(x, sds = 1:3) instead chop_mean_sd(x, sd = 3).","code":""},{"path":[]},{"path":"/reference/chop_mean_sd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(1:10) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  chop(1:10, brk_mean_sd()) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  tab_mean_sd(1:10) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              2              3              3              2"},{"path":"/reference/chop_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into fixed-sized groups — chop_n","title":"Chop into fixed-sized groups — chop_n","text":"chop_n() creates intervals containing fixed number elements. One interval may fewer elements.","code":""},{"path":"/reference/chop_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into fixed-sized groups — chop_n","text":"","code":"chop_n(x, n, ..., close_end = TRUE)  brk_n(n)  tab_n(x, n, ..., close_end = TRUE)"},{"path":"/reference/chop_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into fixed-sized groups — chop_n","text":"x vector. n Integer: number elements interval. ... Passed chop(). close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/chop_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into fixed-sized groups — chop_n","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into fixed-sized groups — chop_n","text":"Note chop_n() sets close_end = TRUE default. Groups may larger n, many duplicated elements x. , warning given.","code":""},{"path":[]},{"path":"/reference/chop_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into fixed-sized groups — chop_n","text":"","code":"chop_n(1:10, 5) #>  [1] [1, 6)  [1, 6)  [1, 6)  [1, 6)  [1, 6)  [6, 10] [6, 10] [6, 10] [6, 10] #> [10] [6, 10] #> Levels: [1, 6) [6, 10]  # too many duplicates x <- rep(1:2, each = 3) chop_n(x, 2) #> Warning: Some intervals contain more than 2 elements #> [1] {1} {1} {1} {2} {2} {2} #> Levels: {1} {2}  tab_n(1:10, 5) #>  [1, 6) [6, 10]  #>       5       5   # fewer elements in one group tab_n(1:10, 4) #>  [1, 5)  [5, 9) [9, 10]  #>       4       4       2"},{"path":"/reference/chop_pretty.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop using pretty breakpoints — chop_pretty","title":"Chop using pretty breakpoints — chop_pretty","text":"chop_pretty() uses base::pretty() calculate breakpoints 1, 2 5 times power 10. look nice graphs.","code":""},{"path":"/reference/chop_pretty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop using pretty breakpoints — chop_pretty","text":"","code":"chop_pretty(x, n = 5, ...)  brk_pretty(n = 5, ...)  tab_pretty(x, n = 5, ...)"},{"path":"/reference/chop_pretty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop using pretty breakpoints — chop_pretty","text":"x vector. n Positive integer passed base::pretty(). many intervals chop ? ... Passed chop() chop_pretty() tab_pretty(); passed base::pretty() brk_pretty().","code":""},{"path":"/reference/chop_pretty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop using pretty breakpoints — chop_pretty","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_pretty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop using pretty breakpoints — chop_pretty","text":"base::pretty() tries return n+1 breakpoints, .e. n intervals, note guaranteed. methods Date POSIXct objects. fine-grained control base::pretty() parameters, use chop(x, brk_pretty(...)).","code":""},{"path":"/reference/chop_pretty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop using pretty breakpoints — chop_pretty","text":"","code":"chop_pretty(1:10) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10) [8, 10) #> [10] {10}    #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10) {10}  chop(1:10, brk_pretty(n = 5, high.u.bias = 0)) #>  [1] [1, 2)  [2, 3)  [3, 4)  [4, 5)  [5, 6)  [6, 7)  [7, 8)  [8, 9)  [9, 10) #> [10] {10}    #> 10 Levels: [1, 2) [2, 3) [3, 4) [4, 5) [5, 6) [6, 7) [7, 8) [8, 9) ... {10}  tab_pretty(1:10) #>  [0, 2)  [2, 4)  [4, 6)  [6, 8) [8, 10)    {10}  #>       1       2       2       2       2       1"},{"path":"/reference/chop_proportions.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into proportions of the range of x — chop_proportions","title":"Chop into proportions of the range of x — chop_proportions","text":"chop_proportions() chops x proportions range, excluding infinite values.","code":""},{"path":"/reference/chop_proportions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into proportions of the range of x — chop_proportions","text":"","code":"chop_proportions(x, proportions, ..., labels = lbl_intervals(raw = TRUE))  brk_proportions(proportions)  tab_proportions(x, proportions, ...)"},{"path":"/reference/chop_proportions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into proportions of the range of x — chop_proportions","text":"x vector. proportions Numeric vector 0 1: proportions x's range ... Passed chop(). labels character vector labels function create labels.","code":""},{"path":"/reference/chop_proportions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into proportions of the range of x — chop_proportions","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_proportions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into proportions of the range of x — chop_proportions","text":"default, labels show raw numeric endpoints. label intervals proportions, use labels = lbl_intervals(raw = FALSE).","code":""},{"path":[]},{"path":"/reference/chop_proportions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into proportions of the range of x — chop_proportions","text":"","code":"chop_proportions(0:10, c(0.2, 0.8)) #>  [1] [0, 2)  [0, 2)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [8, 10] #> [10] [8, 10] [8, 10] #> Levels: [0, 2) [2, 8) [8, 10]"},{"path":"/reference/chop_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by quantiles — chop_quantiles","title":"Chop by quantiles — chop_quantiles","text":"chop_quantiles() chops data quantiles. chop_deciles() convenience shortcut chops deciles.","code":""},{"path":"/reference/chop_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(x, probs, ..., left = is.numeric(x), close_end = TRUE)  chop_deciles(x, ...)  brk_quantiles(probs, ...)  tab_quantiles(x, probs, ..., left = is.numeric(x), close_end = TRUE)  tab_deciles(x, ...)"},{"path":"/reference/chop_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by quantiles — chop_quantiles","text":"x vector. probs vector probabilities quantiles. ... Passed chop(), brk_quantiles() stats::quantile(). left Logical. Left-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/chop_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by quantiles — chop_quantiles","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop by quantiles — chop_quantiles","text":"Note functions set close_end = TRUE default. helps ensure e.g. chop_quantiles(x, c(0, 1/3, 2/3, 1) split data three equal-sized groups. non-numeric x, left set FALSE default. works better calculating \"type 1\" quantiles, since round . See stats::quantile().","code":""},{"path":[]},{"path":"/reference/chop_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(1:10, 1:3/4) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%]  #>  [7] [50%, 75%]  (75%, 100%] (75%, 100%] (75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%] (75%, 100%]  chop(1:10, brk_quantiles(1:3/4)) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%)  #>  [7] [50%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%) [75%, 100%]  chop_deciles(1:10) #>  [1] [0%, 10%)   [10%, 20%)  [20%, 30%)  [30%, 40%)  [40%, 50%)  [50%, 60%)  #>  [7] [60%, 70%)  [70%, 80%)  [80%, 90%)  [90%, 100%] #> 10 Levels: [0%, 10%) [10%, 20%) [20%, 30%) [30%, 40%) [40%, 50%) ... [90%, 100%]  # to label by the quantiles themselves: chop_quantiles(1:10, 1:3/4, lbl_intervals(raw = TRUE)) #>  [1] [1, 3.25)   [1, 3.25)   [1, 3.25)   [3.25, 5.5) [3.25, 5.5) [5.5, 7.75] #>  [7] [5.5, 7.75] (7.75, 10]  (7.75, 10]  (7.75, 10]  #> Levels: [1, 3.25) [3.25, 5.5) [5.5, 7.75] (7.75, 10]  set.seed(42) tab_quantiles(rnorm(100), probs = 1:3/4, label = lbl_intervals(raw = TRUE)) #> [-2.993, -0.6167) [-0.6167, 0.0898)  [0.0898, 0.6616]   (0.6616, 2.287]  #>                25                25                25                25"},{"path":"/reference/chop_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into fixed-width intervals — chop_width","title":"Chop into fixed-width intervals — chop_width","text":"chop_width() chops x intervals fixed width.","code":""},{"path":"/reference/chop_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into fixed-width intervals — chop_width","text":"","code":"chop_width(x, width, start, ..., left = sign(width) > 0)  brk_width(width, start)  # S3 method for default brk_width(width, start)  tab_width(x, width, start, ..., left = sign(width) > 0)"},{"path":"/reference/chop_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into fixed-width intervals — chop_width","text":"x vector. width Width intervals. start Starting point intervals. default smallest finite x (largest width negative). ... Passed chop(). left Logical. Left-closed breaks?","code":""},{"path":"/reference/chop_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into fixed-width intervals — chop_width","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_width.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into fixed-width intervals — chop_width","text":"width negative, chop_width() sets left = FALSE intervals go downwards start.","code":""},{"path":[]},{"path":"/reference/chop_width.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into fixed-width intervals — chop_width","text":"","code":"chop_width(1:10, 2) #>  [1] [1, 3)  [1, 3)  [3, 5)  [3, 5)  [5, 7)  [5, 7)  [7, 9)  [7, 9)  [9, 11) #> [10] [9, 11) #> Levels: [1, 3) [3, 5) [5, 7) [7, 9) [9, 11)  chop_width(1:10, 2, start = 0) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10) [8, 10) #> [10] {10}    #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10) {10}  chop_width(1:9, -2) #> [1] {1}    (1, 3] (1, 3] (3, 5] (3, 5] (5, 7] (5, 7] (7, 9] (7, 9] #> Levels: {1} (1, 3] (3, 5] (5, 7] (7, 9]  chop(1:10, brk_width(2, 0)) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10) [8, 10) #> [10] {10}    #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10) {10}  tab_width(1:10, 2, start = 0) #>  [0, 2)  [2, 4)  [4, 6)  [6, 8) [8, 10)    {10}  #>       1       2       2       2       2       1"},{"path":"/reference/exactly.html","id":null,"dir":"Reference","previous_headings":"","what":"Define singleton intervals explicitly — exactly","title":"Define singleton intervals explicitly — exactly","text":"exactly() duplicates input. lets define singleton intervals like : chop(x, c(1, exactly(2), 3)). chop(x, c(1, 2, 2, 3)) conveys intent clearly.","code":""},{"path":"/reference/exactly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define singleton intervals explicitly — exactly","text":"","code":"exactly(x)"},{"path":"/reference/exactly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define singleton intervals explicitly — exactly","text":"x numeric vector.","code":""},{"path":"/reference/exactly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define singleton intervals explicitly — exactly","text":"rep(x, = 2).","code":""},{"path":"/reference/exactly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define singleton intervals explicitly — exactly","text":"","code":"chop(1:10, c(2, exactly(5), 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]  # same: chop(1:10, c(2, 5, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]"},{"path":"/reference/fillet.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop data precisely (for programmers) — fillet","title":"Chop data precisely (for programmers) — fillet","text":"Chop data precisely (programmers)","code":""},{"path":"/reference/fillet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(x, breaks, labels = lbl_intervals(), left = TRUE, close_end = FALSE)"},{"path":"/reference/fillet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop data precisely (for programmers) — fillet","text":"x vector. breaks numeric vector cut-points function create cut-points x. labels character vector labels function create labels. left Logical. Left-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/fillet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop data precisely (for programmers) — fillet","text":"fillet() returns factor length x, representing intervals containing value x.","code":""},{"path":"/reference/fillet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop data precisely (for programmers) — fillet","text":"fillet() calls chop() extend = FALSE drop = FALSE. ensures get breaks labels ask . programming, consider using fillet() instead chop().","code":""},{"path":[]},{"path":"/reference/fillet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(1:10, c(2, 5, 8)) #>  [1] <NA>   [2, 5) [2, 5) [2, 5) [5, 8) [5, 8) [5, 8) <NA>   <NA>   <NA>   #> Levels: [2, 5) [5, 8)"},{"path":"/reference/knife.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated — knife","title":"Deprecated — knife","text":"knife() deprecated favour purrr::partial().","code":""},{"path":"/reference/knife.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated — knife","text":"","code":"knife(...)"},{"path":"/reference/knife.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated — knife","text":"... Parameters chop().","code":""},{"path":"/reference/knife.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated — knife","text":"function.","code":""},{"path":"/reference/lbl_dash.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"label style user-friendly, distinguish left- right-closed intervals. good continuous data expect points exactly breaks.","code":""},{"path":"/reference/lbl_dash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"","code":"lbl_dash(   symbol = em_dash(),   fmt = NULL,   single = \"{l}\",   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_dash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"symbol String: symbol use dash. fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_dash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_dash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"want unicode output, use lbl_dash(\"-\").","code":""},{"path":"/reference/lbl_dash.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_dash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"","code":"chop(1:10, c(2, 5, 8), lbl_dash()) #>  [1] 1—2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: 1—2 2—5 5—8 8—10  chop(1:10, c(2, 5, 8), lbl_dash(\" to \", fmt = \"%.1f\")) #>  [1] 1.0 to 2.0  2.0 to 5.0  2.0 to 5.0  2.0 to 5.0  5.0 to 8.0  5.0 to 8.0  #>  [7] 5.0 to 8.0  8.0 to 10.0 8.0 to 10.0 8.0 to 10.0 #> Levels: 1.0 to 2.0 2.0 to 5.0 5.0 to 8.0 8.0 to 10.0  chop(1:10, c(2, 5, 8), lbl_dash(first = \"<{r}\")) #>  [1] <2   2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: <2 2—5 5—8 8—10  pretty <- function (x) prettyNum(x, big.mark = \",\", digits = 1) chop(runif(10) * 10000, c(3000, 7000), lbl_dash(\" to \", fmt = pretty)) #>  [1] 7,000 to 9,677 3,000 to 7,000 7,000 to 9,677 3,000 to 7,000 1,579 to 3,000 #>  [6] 3,000 to 7,000 7,000 to 9,677 3,000 to 7,000 1,579 to 3,000 1,579 to 3,000 #> Levels: 1,579 to 3,000 3,000 to 7,000 7,000 to 9,677"},{"path":"/reference/lbl_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"Label discrete data — lbl_discrete","title":"Label discrete data — lbl_discrete","text":"lbl_discrete() creates labels discrete data, integers. example, breaks c(1, 3, 4, 6, 7) labelled: \"1-2\", \"3\", \"4-5\", \"6-7\".","code":""},{"path":"/reference/lbl_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label discrete data — lbl_discrete","text":"","code":"lbl_discrete(   symbol = em_dash(),   unit = 1,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL )"},{"path":"/reference/lbl_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label discrete data — lbl_discrete","text":"symbol String: symbol use dash. unit Minimum difference distinct values data. integers, 1. fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details.","code":""},{"path":"/reference/lbl_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label discrete data — lbl_discrete","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_discrete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label discrete data — lbl_discrete","text":"check done data discrete-valued. , labels may misleading. , discrete-valued means x < y, x <= y - unit. aware Date objects may non-integer values. See Date.","code":""},{"path":"/reference/lbl_discrete.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label discrete data — lbl_discrete","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label discrete data — lbl_discrete","text":"","code":"tab(1:7, c(1, 3, 5), lbl_discrete()) #> 1—2 3—4 5—7  #>   2   2   3   tab(1:7, c(3, 5), lbl_discrete(first = \"<= {r}\")) #> <= 2  3—4  5—7  #>    2    2    3   tab(1:7 * 1000, c(1, 3, 5) * 1000, lbl_discrete(unit = 1000)) #> 1000—2000 3000—4000 5000—7000  #>         2         2         3   # Misleading labels for non-integer data chop(2.5, c(1, 3, 5), lbl_discrete()) #> [1] 1—2 #> Levels: 1—2"},{"path":"/reference/lbl_endpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their left or right endpoints — lbl_endpoint","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"useful left endpoint unambiguously indicates interval. cases may give errors due duplicate labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)"},{"path":"/reference/lbl_endpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"fmt String function. format break endpoints. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? left Flag. Use left endpoint right endpoint?","code":""},{"path":"/reference/lbl_endpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"chop(1:10, c(2, 5, 8), lbl_endpoint(left = TRUE)) #>  [1] 1 2 2 2 5 5 5 8 8 8 #> Levels: 1 2 5 8 chop(1:10, c(2, 5, 8), lbl_endpoint(left = FALSE)) #>  [1] 2  5  5  5  8  8  8  10 10 10 #> Levels: 2 5 8 10 if (requireNamespace(\"lubridate\")) {   tab_width(           as.Date(\"2000-01-01\") + 0:365,          months(1),          labels = lbl_endpoint(fmt = \"%b\")        ) } #> Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec  #>  31  29  31  30  31  30  31  31  30  31  30  31"},{"path":"/reference/lbl_endpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their left or right endpoints — lbl_endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"useful left endpoint unambiguously indicates interval. cases may give errors due duplicate labels.","code":""},{"path":"/reference/lbl_endpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"","code":"lbl_endpoints(   left = TRUE,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE )  lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)"},{"path":"/reference/lbl_endpoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"left Flag. Use left endpoint right endpoint? fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_endpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_endpoints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"lbl_endpoint() deprecated. use .","code":""},{"path":"/reference/lbl_endpoints.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_endpoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"","code":"chop(1:10, c(2, 5, 8), lbl_endpoints(left = TRUE)) #>  [1] 1 2 2 2 5 5 5 8 8 8 #> Levels: 1 2 5 8 chop(1:10, c(2, 5, 8), lbl_endpoints(left = FALSE)) #>  [1] 2  5  5  5  8  8  8  10 10 10 #> Levels: 2 5 8 10 if (requireNamespace(\"lubridate\")) {   tab_width(           as.Date(\"2000-01-01\") + 0:365,          months(1),          labels = lbl_endpoints(fmt = \"%b\")        ) } #> Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec  #>  31  29  31  30  31  30  31  31  30  31  30  31"},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"lbl_format(fmt, fmt1 = \"%.3g\", raw = FALSE)"},{"path":"/reference/lbl_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. fmt1 Format breaks consisting single value. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_format.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"labels let format breaks arbitrarily, using either string (passed sprintf()) function. fmt function, must accept two arguments, representing left right endpoints interval. breaks non-numeric, can use \"%s\" string fmt. breaks converted character case. lbl_format() \"questioning\" stage. alternative, consider using lbl_dash() lbl_intervals() fmt argument.","code":""},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\")) #>  1 to 3       3  3 to 7 7 to 10  #>       2       1       3       4  tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\", \"Exactly %.3g\")) #>    1 to 3 Exactly 3    3 to 7   7 to 10  #>         2         1         3         4   percent2 <- function (x, y) {   sprintf(\"%.2f%% - %.2f%%\", x*100, y*100) } tab(runif(100), c(0.25, 0.5, .75),       labels = lbl_format(percent2)) #>  0.64% - 25.00% 25.00% - 50.00% 50.00% - 75.00% 75.00% - 98.41%  #>              21              20              33              26"},{"path":"/reference/lbl_glue.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals using the glue package — lbl_glue","title":"Label chopped intervals using the glue package — lbl_glue","text":"Use \"{l}\" \"{r}\" show left right endpoints intervals.","code":""},{"path":"/reference/lbl_glue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals using the glue package — lbl_glue","text":"","code":"lbl_glue(   label,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE,   ... )"},{"path":"/reference/lbl_glue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals using the glue package — lbl_glue","text":"label glue string passed glue::glue(). fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? ... arguments passed glue::glue().","code":""},{"path":"/reference/lbl_glue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals using the glue package — lbl_glue","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_glue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals using the glue package — lbl_glue","text":"following variables available glue string: l character vector left endpoints intervals. r character vector right endpoints intervals. l_closed logical vector. Elements TRUE left endpoint closed. r_closed logical vector, TRUE right endpoint closed. Endpoints formatted fmt passed glue().","code":""},{"path":"/reference/lbl_glue.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals using the glue package — lbl_glue","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_glue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals using the glue package — lbl_glue","text":"","code":"tab(1:10, c(1, 3, 3, 7),     label = lbl_glue(\"{l} to {r}\", single = \"Exactly {l}\")) #>    1 to 3 Exactly 3    3 to 7   7 to 10  #>         2         1         3         4   tab(1:10 * 1000, c(1, 3, 5, 7) * 1000,     label = lbl_glue(\"{l}-{r}\", fmt = function(x) prettyNum(x, big.mark=','))) #>  1,000-3,000  3,000-5,000  5,000-7,000 7,000-10,000  #>            2            2            2            4   # reproducing lbl_intervals(): interval_left <- \"{ifelse(l_closed, '[', '(')}\" interval_right <- \"{ifelse(r_closed, ']', ')')}\" glue_string <- paste0(interval_left, \"{l}\", \", \", \"{r}\", interval_right) tab(1:10, c(1, 3, 3, 7), label = lbl_glue(glue_string, single = \"{{{l}}}\")) #>  [1, 3)     {3}  (3, 7) [7, 10]  #>       2       1       3       4"},{"path":"/reference/lbl_intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals using set notation — lbl_intervals","title":"Label chopped intervals using set notation — lbl_intervals","text":"labels exact, since show whether intervals \"closed\" \"open\", .e. whether include endpoints.","code":""},{"path":"/reference/lbl_intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"lbl_intervals(   fmt = NULL,   single = \"{{{l}}}\",   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals using set notation — lbl_intervals","text":"fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_intervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals using set notation — lbl_intervals","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_intervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals using set notation — lbl_intervals","text":"Mathematical set notation looks like : [, b]: numbers x <= x <= b; (, b): numbers < x < b; [, b): numbers <= x < b; (, b]: numbers < x <= b; {}: just number exactly.","code":""},{"path":"/reference/lbl_intervals.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals using set notation — lbl_intervals","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_intervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"tab(-10:10, c(-3, 0, 0, 3),       labels = lbl_intervals()) #> [-10, -3)   [-3, 0)       {0}    (0, 3)   [3, 10]  #>         7         3         1         2         8   tab_evenly(runif(20), 10,       labels = lbl_intervals(fmt = percent)) #> [4.835%, 13.97%)  [13.97%, 23.1%)  [23.1%, 32.23%) [32.23%, 41.36%)  #>                2                2                3                2  #> [41.36%, 50.49%) [50.49%, 59.62%) [59.62%, 68.75%) [77.88%, 87.02%)  #>                2                4                1                2  #> [87.02%, 96.15%]  #>                2"},{"path":"/reference/lbl_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals in a user-defined sequence — lbl_manual","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"lbl_manual() uses arbitrary sequence label intervals. sequence short, pasted repeated.","code":""},{"path":"/reference/lbl_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"lbl_manual(sequence, fmt = \"%s\")"},{"path":"/reference/lbl_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"sequence character vector labels. fmt String function. format break endpoints.","code":""},{"path":"/reference/lbl_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_manual.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"chop(1:10, c(2, 5, 8), lbl_manual(c(\"w\", \"x\", \"y\", \"z\"))) #>  [1] w x x x y y y z z z #> Levels: w x y z  # if labels need repeating: chop(1:10, 1:10, lbl_manual(c(\"x\", \"y\", \"z\"))) #>  [1] x    y    z    xx   yy   zz   xxx  yyy  zzz  xxxx #> Levels: x y z xx yy zz xxx yyy zzz xxxx"},{"path":"/reference/lbl_midpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their midpoints — lbl_midpoints","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"uses midpoint interval label.","code":""},{"path":"/reference/lbl_midpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"","code":"lbl_midpoints(   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_midpoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"fmt String function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_midpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_midpoints.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_midpoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"","code":"chop(1:10, c(2, 5, 8), lbl_midpoints()) #>  [1] 1.5 3.5 3.5 3.5 6.5 6.5 6.5 9   9   9   #> Levels: 1.5 3.5 6.5 9"},{"path":"/reference/lbl_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals in sequence — lbl_seq","title":"Label chopped intervals in sequence — lbl_seq","text":"lbl_seq() labels intervals sequentially, using numbers letters.","code":""},{"path":"/reference/lbl_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"lbl_seq(start = \"a\")"},{"path":"/reference/lbl_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in sequence — lbl_seq","text":"start String. template sequence. See .","code":""},{"path":"/reference/lbl_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals in sequence — lbl_seq","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals in sequence — lbl_seq","text":"start shows first element sequence. must contain exactly one character set \"\", \"\", \"\", \"\" \"1\". later elements: \"\" replaced \"\", \"b\", \"c\", ... \"\" replaced \"\", \"B\", \"C\", ... \"\" replaced lower-case Roman numerals \"\", \"ii\", \"iii\", ... \"\" replaced upper-case Roman numerals \"\", \"II\", \"III\", ... \"1\" replaced numbers \"1\", \"2\", \"3\", ... characters retained -.","code":""},{"path":[]},{"path":"/reference/lbl_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"chop(1:10, c(2, 5, 8), lbl_seq()) #>  [1] a b b b c c c d d d #> Levels: a b c d  chop(1:10, c(2, 5, 8), lbl_seq(\"i.\")) #>  [1] i.   ii.  ii.  ii.  iii. iii. iii. iv.  iv.  iv.  #> Levels: i. ii. iii. iv.  chop(1:10, c(2, 5, 8), lbl_seq(\"(A)\")) #>  [1] (A) (B) (B) (B) (C) (C) (C) (D) (D) (D) #> Levels: (A) (B) (C) (D)"},{"path":"/reference/non-standard-types.html","id":null,"dir":"Reference","previous_headings":"","what":"Tips for chopping non-standard types — non-standard-types","title":"Tips for chopping non-standard types — non-standard-types","text":"Santoku can handle many non-standard types.","code":""},{"path":"/reference/non-standard-types.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tips for chopping non-standard types — non-standard-types","text":"objects can compared using <, == etc. choppable. Objects converted numeric handled within R code, may slower. Character x breaks chopped warning. x breaks type, able cast type, usually using vctrs::vec_cast_common(). chopping operations make sense, example, chop_mean_sd() character vector. indexed objects stats::ts() objects, indices dropped result. get errors, try setting extend = FALSE (also file bug report). request support type, open issue Github.","code":""},{"path":[]},{"path":"/reference/percent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple percentage formatter — percent","title":"Simple percentage formatter — percent","text":"percent() formats x percentage. wider range formatters, consider scales package.","code":""},{"path":"/reference/percent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple percentage formatter — percent","text":"","code":"percent(x)"},{"path":"/reference/percent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple percentage formatter — percent","text":"x Numeric values.","code":""},{"path":"/reference/percent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple percentage formatter — percent","text":"x formatted percent.","code":""},{"path":"/reference/percent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple percentage formatter — percent","text":"","code":"percent(0.5) #> [1] \"50%\""},{"path":"/reference/santoku-cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — santoku-cast","title":"Internal functions — santoku-cast","text":"Internal functions","code":""},{"path":"/reference/santoku-cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — santoku-cast","text":"","code":"santoku_cast_common.default(x, y)  santoku_cast_common.double(x, y)  santoku_cast_common.Date(x, y)  santoku_cast_common.POSIXct(x, y)  santoku_cast_common.ts(x, y)  santoku_cast_common.zoo(x, y)  santoku_cast_common.integer64(x, y)  santoku_cast_common.hexmode(x, y)  santoku_cast_common.octmode(x, y)"},{"path":"/reference/santoku-cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — santoku-cast","text":"x, y Vectors cast.","code":""},{"path":"/reference/santoku-cast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal functions — santoku-cast","text":"list.","code":""},{"path":"/reference/santoku-package.html","id":null,"dir":"Reference","previous_headings":"","what":"A versatile cutting tool for R — santoku-package","title":"A versatile cutting tool for R — santoku-package","text":"santoku tool cutting data intervals. provides function chop(), similar base R's cut() Hmisc::cut2(). chop(x, breaks) takes vector x returns factor length, coding interval element x falls .","code":""},{"path":"/reference/santoku-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A versatile cutting tool for R — santoku-package","text":"advantages santoku: default, chop() always covers whole range data, get unexpected NA values. Unlike cut() cut2(), chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. Flexible easy labelling. Convenience functions creating quantile intervals, evenly-spaced intervals equal-sized groups. Convenience functions quickly tabulate chopped data. Can chop numbers, dates, date-times objects. advantages make santoku especially useful exploratory analysis, may know range data advance. get started, read vignette:   details, start documentation chop().","code":"vignette(\"santoku\")"},{"path":[]},{"path":"/reference/santoku-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A versatile cutting tool for R — santoku-package","text":"Maintainer: David Hugh-Jones davidhughjones@gmail.com contributors: Daniel Possenriede possenriede@gmail.com [contributor]","code":""},{"path":"/reference/tab.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate data by intervals — tab","title":"Tabulate data by intervals — tab","text":"functions call related chop_xxx function, call table() result.","code":""},{"path":"/reference/tab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate data by intervals — tab","text":"","code":"tab(...)  tab_width(...)  tab_evenly(...)  tab_n(...)  tab_mean_sd(...)  tab_quantiles(...)  tab_deciles(...)  tab_equally(...)"},{"path":"/reference/tab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate data by intervals — tab","text":"... Passed chop","code":""},{"path":"/reference/tab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tabulate data by intervals — tab","text":"table().","code":""},{"path":"/reference/tab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate data by intervals — tab","text":"","code":"tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3   tab_mean_sd(1:10) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              2              3              3              2   tab_equally(rpois(50, 4), groups = 4) #>   [0%, 25%)  [25%, 50%)  [50%, 75%) [75%, 100%]  #>          10          12           8          20"},{"path":[]},{"path":"/news/index.html","id":"breaking-changes-0-8-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"santoku 0.8.0","text":"lbl_endpoint() renamed lbl_endpoints(). old version trigger deprecation warning. lbl_endpoints() gains first, last single arguments like labelling functions.","code":""},{"path":"/news/index.html","id":"other-changes-0-8-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.8.0","text":"New chop_pretty(), brk_pretty() tab_pretty() functions use base::pretty() calculate attractive breakpoints. Thanks @davidhodge931. New chop_proportions(), brk_proportions() tab_proportions() functions chop x proportions range. chop_equally() now uses lbl_intervals(raw = TRUE) default, bringing line chop_evenly(), chop_width() chop_n(). New lbl_midpoints() function labels breaks midpoints. lbl_discrete() gains single argument. can now chop ts, xts::xts zoo::zoo objects. Date objects POSIXct breaks, vice versa bit64::integer64 doubles Bugfix: lbl_discrete() sometimes ugly label formatting.","code":""},{"path":"/news/index.html","id":"santoku-070","dir":"Changelog","previous_headings":"","what":"santoku 0.7.0","title":"santoku 0.7.0","text":"CRAN release: 2022-03-18","code":""},{"path":"/news/index.html","id":"breaking-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"santoku 0.7.0","text":"labelling functions, first last arguments now passed glue::glue(). Variables l r represent left right endpoints intervals. chop_mean_sd() now takes vector sds standard deviations, rather single maximum number sd standard deviations. Write e.g.  chop_mean_sd(sds = 1:3) rather chop_mean_sd(sd = 3). sd argument deprecated. groups argument chop_evenly(), deprecated 0.4.0, removed. brk_left() brk_right(), deprecated 0.4.0, removed. knife(), deprecated 0.4.0, removed. lbl_format(), questioning since 0.4.0, removed. Arguments lbl_dash() lbl_intervals() reordered consistency labelling functions.","code":""},{"path":"/news/index.html","id":"other-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.7.0","text":"Character vectors chopped lexicographic order, optional warning. problems chopping vector type, file bug report. glue package become hard dependency. used many places format labels. new lbl_glue() function using glue package. Thanks @dpprdan. can now set labels = NULL return integer codes. Arguments first, last single can used lbl_intervals() lbl_dash(), override first last interval labels, label singleton intervals. lbl_dash() lbl_discrete() use unicode em-dash possible. brk_default() throws error breaks sorted.","code":""},{"path":"/news/index.html","id":"bugfixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"santoku 0.7.0","text":"Bugfix: tab() friends longer display x variable name. Bugfix: lbl_endpoint() erroring types breaks.","code":""},{"path":"/news/index.html","id":"santoku-060","dir":"Changelog","previous_headings":"","what":"santoku 0.6.0","title":"santoku 0.6.0","text":"CRAN release: 2021-11-04 New arguments first last lbl_dash() lbl_discrete() allow override first last interval labels. Fixes CRAN.","code":""},{"path":"/news/index.html","id":"santoku-050","dir":"Changelog","previous_headings":"","what":"santoku 0.5.0","title":"santoku 0.5.0","text":"CRAN release: 2020-08-27 sets left = FALSE default. Also works negative time intervals.","code":""},{"path":"/news/index.html","id":"santoku-041","dir":"Changelog","previous_headings":"","what":"santoku 0.4.1","title":"santoku 0.4.1","text":"CRAN release: 2020-06-16 Bugfix: chop(1:4, 1) erroring.","code":""},{"path":"/news/index.html","id":"santoku-040","dir":"Changelog","previous_headings":"","what":"santoku 0.4.0","title":"santoku 0.4.0","text":"CRAN release: 2020-06-09","code":""},{"path":"/news/index.html","id":"interface-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Interface changes","title":"santoku 0.4.0","text":"new version interface changes. based user experience, designed make using chop() intuitive predictable. chop() two new arguments, left close_end. Using left = FALSE simpler intuitive wrapping breaks brk_right(). brk_left() brk_right() kept now, used wrap break functions. Using close_end simpler passing close_end brk_left() brk_right() (longer accept argument directly). left = TRUE default, except non-numeric objects chop_quantiles() chop_equally(), left = FALSE works better. close_end now FALSE default. prevents user surprises e.g. chop(3, 1:3) puts 3 different category chop(3, 1:4). close_end TRUE default chop_quantiles(), chop_n() similar functions. ensures e.g.  chop_quantiles(x, c(0, 1/3, 2/3, 1)) expect. groups argument chop_evenly() renamed groups intervals. make easier remember difference chop_evenly() chop_equally(). (Chop evenly n equal-width intervals, chop equally n equal-sized groups.) knife() deprecated keep interface slim focused. Use purrr::partial() instead.","code":""},{"path":"/news/index.html","id":"other-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.4.0","text":"Date datetime (POSIXct) objects can now chopped. chop_width() accepts difftime, lubridate::period lubridate::duration objects chop_ functions work well. Many labelling functions new fmt argument. can string interpreted sprintf() format(), 1-argument formatting function break endpoints, e.g. scales::label_percent(). Experimental: lbl_discrete() discrete data integers () dates. new lbl_endpoint() function labelling intervals solely left right endpoint. brk_mean_sd() now accepts non-integer positive numbers. Add brk_equally() symmetry chop_equally(). Minor tweaks chop_deciles(). Bugfix: lbl_format() wasn’t accepting numeric formats, even raw = TRUE. Thanks Sharla Gelfand.","code":""},{"path":"/news/index.html","id":"santoku-030","dir":"Changelog","previous_headings":"","what":"santoku 0.3.0","title":"santoku 0.3.0","text":"CRAN release: 2020-01-24 First CRAN release. Changed kut() kiru(). kiru() alternative spelling chop(), use tidyr package loaded. lbl_sequence() become lbl_manual(). lbl_letters() friends replaced lbl_seq(): replace lbl_letters() use lbl_seq() replace lbl_LETTERS() use lbl_seq(\"\") replace lbl_roman() use lbl_seq(\"\") replace lbl_ROMAN() use lbl_seq(\"\") replace lbl_numerals() use lbl_seq(\"1\") complex formatting use e.g. lbl_seq(\":\"), lbl_seq(\"()\")","code":""},{"path":"/news/index.html","id":"santoku-020","dir":"Changelog","previous_headings":"","what":"santoku 0.2.0","title":"santoku 0.2.0","text":"Added NEWS.md file track changes package. Default labels extend = NULL changed, [-Inf, ... ..., Inf] [min(x), ... ..., max(x)].","code":""}]
