[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2019 David Hugh-Jones Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/TODO.html","id":null,"dir":"","previous_headings":"","what":"TODO","title":"TODO","text":"tests left close_end arguments tests brk_default brk_width() needs tests match guarantees documentation ditto brk_evenly() now uses implementation guarantee exactly intervals intervals systematic tests brk_* functions problem moment vec_cast() highly unreliable never know particular class accept Inf. infinity class fine, go existing breaks object underlying class? NB requires new way create labels, kinda sucks….","code":""},{"path":"/TODO.html","id":"thoughts-on-errors","dir":"","previous_headings":"","what":"Thoughts on errors","title":"TODO","text":"Exception: x wrong class type. e.g. brk_manual() extend set. cases, e.g. brk_evenly() don’t need make guarantee.","code":""},{"path":"/TODO.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"TODO","text":"alternative x non-numeric. makes surprise rarer, rare surprises can worse… adds complexity since functions generic. another alternative: chop sets left = FALSE non-numeric x. Probably better. drop default ! isTRUE(extend) .e. FALSE extend = TRUE?","code":""},{"path":"/TODO.html","id":"questions-with-a-provisional-answer","dir":"","previous_headings":"","what":"Questions with a (provisional) answer","title":"TODO","text":", labels = NULL integer codes though. sense , unless someone asks. Oh, someone just ask; generally though. . don’t want people set position, distinguish initial arguments. Current answer: fuck ’em. (NB: just kidding. huge tidyverse fan.) provide kiru(). REPL, people can just use kiru() load santoku first. load santoku second, ’ll use tidyr::chop(), reading documentation, suspect rare. programming, people probably used fully qualified name anyway. think default “necessary” (extend = NULL); always extend Inf, -Inf break labels data-dependent Tension wanting something predictable new data, vs. something readable tab_*. E.g. surely return labels , b, c. means aren’t always extending. lets people e.g. chop(rnorm(100), -2:2, LETTERS) might hide errors overall ’m maybe label functions access x? informed breaks got extended? breaks object know extend labels? current solution: labels get extend think better: breaks objects include suggested labels user can override. way always info necessary. choosing break numbers (may actual values, e.g quantiles std errs 0) formatting numbers, dashes, set notation etc maybe brk_* functions always return break numbers; labels decide format ? warning? currently error throw error cases e.g. brk_quantiles, brk_width, data may work well e.g. NA. empty set breaks?","code":"tab_size(1:9, 3, lbl_seq())"},{"path":"/TODO.html","id":"possible-interfaces","dir":"","previous_headings":"","what":"Possible interfaces","title":"TODO","text":"hist_xxx functions histograms/barplots? (treat singletons?) grp_xxx group_by? Hmmm… New label interface replace lbl_sequence: lbl_style(\"1.\"), lbl_style(\"()\"), lbl_style(\"\") etc.? Still wonder, drop extend adds complexity just () extend() new breaks functions?","code":""},{"path":"/TODO.html","id":"other-ideas","dir":"","previous_headings":"","what":"Other ideas","title":"TODO","text":"Speedup categorize checking left intervals, add 1 past interval [: actually fewer checks end…] Speedup using pointers? hmm, magic…","code":""},{"path":"/articles/santoku.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Introduction to santoku","text":"Santoku package cutting data intervals. provides chop(), replacement base R’s cut() function, well several convenience functions cut different kinds intervals. install santoku, run:","code":"install.packages(\"santoku\")"},{"path":"/articles/santoku.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic usage","title":"Introduction to santoku","text":"Use chop() like cut(), cut numeric data intervals set breaks. chop() returns factor. data beyond limits breaks, extended automatically: chop single number separate category, put number twice breaks: quickly produce table chopped data, use tab():","code":"library(santoku)  x <- runif(10, 0, 10) (chopped <- chop(x, breaks = 0:10)) #>  [1] [4, 5)  [8, 9)  [3, 4)  [4, 5)  [7, 8)  [9, 10] [6, 7)  [8, 9)  [1, 2)  #> [10] [4, 5)  #> Levels: [1, 2) [3, 4) [4, 5) [6, 7) [7, 8) [8, 9) [9, 10] data.frame(x, chopped) #>        x chopped #> 1  4.978  [4, 5) #> 2  8.970  [8, 9) #> 3  3.392  [3, 4) #> 4  4.677  [4, 5) #> 5  7.057  [7, 8) #> 6  9.708 [9, 10] #> 7  6.714  [6, 7) #> 8  8.377  [8, 9) #> 9  1.086  [1, 2) #> 10 4.495  [4, 5) chopped <- chop(x, breaks = 3:7) data.frame(x, chopped) #>        x    chopped #> 1  4.978     [4, 5) #> 2  8.970 [7, 9.708] #> 3  3.392     [3, 4) #> 4  4.677     [4, 5) #> 5  7.057 [7, 9.708] #> 6  9.708 [7, 9.708] #> 7  6.714     [6, 7) #> 8  8.377 [7, 9.708] #> 9  1.086 [1.086, 3) #> 10 4.495     [4, 5) x_fives <- x x_fives[1:5] <- 5 chopped <- chop(x_fives, c(2, 5, 5, 8)) data.frame(x_fives, chopped) #>    x_fives    chopped #> 1    5.000        {5} #> 2    5.000        {5} #> 3    5.000        {5} #> 4    5.000        {5} #> 5    5.000        {5} #> 6    9.708 [8, 9.708] #> 7    6.714     (5, 8) #> 8    8.377 [8, 9.708] #> 9    1.086 [1.086, 2) #> 10   4.495     [2, 5) tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3"},{"path":"/articles/santoku.html","id":"more-ways-to-chop","dir":"Articles","previous_headings":"","what":"More ways to chop","title":"Introduction to santoku","text":"chop fixed-width intervals, starting minimum value, use chop_width(): chop fixed number intervals, width, use chop_evenly(): chop groups fixed number members, use chop_n(): chop fixed number groups, number elements, use chop_equally(): chop data quantiles, use chop_quantiles(): chop data proportions data range, use chop_proportions(): can think six functions logically arranged table. Different ways chop size chop data standard deviations around mean, use chop_mean_sd(): chop data attractive intervals, use chop_pretty(). selects intervals multiple 2, 5 10. ’s useful producing bar plots. tab_n(), tab_width(), friends act similarly tab(), calling related chop_* function table() result.","code":"chopped <- chop_width(x, 2) data.frame(x, chopped) #>        x        chopped #> 1  4.978 [3.086, 5.086) #> 2  8.970 [7.086, 9.086) #> 3  3.392 [3.086, 5.086) #> 4  4.677 [3.086, 5.086) #> 5  7.057 [5.086, 7.086) #> 6  9.708 [9.086, 11.09] #> 7  6.714 [5.086, 7.086) #> 8  8.377 [7.086, 9.086) #> 9  1.086 [1.086, 3.086) #> 10 4.495 [3.086, 5.086) chopped <- chop_evenly(x, intervals = 3) data.frame(x, chopped) #>        x        chopped #> 1  4.978  [3.96, 6.834) #> 2  8.970 [6.834, 9.708] #> 3  3.392  [1.086, 3.96) #> 4  4.677  [3.96, 6.834) #> 5  7.057 [6.834, 9.708] #> 6  9.708 [6.834, 9.708] #> 7  6.714  [3.96, 6.834) #> 8  8.377 [6.834, 9.708] #> 9  1.086  [1.086, 3.96) #> 10 4.495  [3.96, 6.834) chopped <- chop_n(x, 4) table(chopped) #> chopped #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 chopped <- chop_equally(x, groups = 5) table(chopped) #> chopped #> [1.086, 4.275) [4.275, 4.858) [4.858, 6.851) [6.851, 8.495) [8.495, 9.708]  #>              2              2              2              2              2 chopped <- chop_quantiles(x, c(0.25, 0.5, 0.75)) data.frame(x, chopped) #>        x     chopped #> 1  4.978  [25%, 50%) #> 2  8.970 [75%, 100%] #> 3  3.392   [0%, 25%) #> 4  4.677  [25%, 50%) #> 5  7.057  [50%, 75%) #> 6  9.708 [75%, 100%] #> 7  6.714  [50%, 75%) #> 8  8.377 [75%, 100%] #> 9  1.086   [0%, 25%) #> 10 4.495   [0%, 25%) chopped <- chop_proportions(x, c(0.25, 0.5, 0.75)) data.frame(x, chopped) #>        x        chopped #> 1  4.978 [3.242, 5.397) #> 2  8.970 [7.552, 9.708] #> 3  3.392 [3.242, 5.397) #> 4  4.677 [3.242, 5.397) #> 5  7.057 [5.397, 7.552) #> 6  9.708 [7.552, 9.708] #> 7  6.714 [5.397, 7.552) #> 8  8.377 [7.552, 9.708] #> 9  1.086 [1.086, 3.242) #> 10 4.495 [3.242, 5.397) chopped <- chop_mean_sd(x) data.frame(x, chopped) #>        x        chopped #> 1  4.978  [-1 sd, 0 sd) #> 2  8.970   [1 sd, 2 sd) #> 3  3.392  [-1 sd, 0 sd) #> 4  4.677  [-1 sd, 0 sd) #> 5  7.057   [0 sd, 1 sd) #> 6  9.708   [1 sd, 2 sd) #> 7  6.714   [0 sd, 1 sd) #> 8  8.377   [0 sd, 1 sd) #> 9  1.086 [-2 sd, -1 sd) #> 10 4.495  [-1 sd, 0 sd) chopped <- chop_pretty(x) data.frame(x, chopped) #>        x chopped #> 1  4.978  [4, 6) #> 2  8.970 [8, 10] #> 3  3.392  [2, 4) #> 4  4.677  [4, 6) #> 5  7.057  [6, 8) #> 6  9.708 [8, 10] #> 7  6.714  [6, 8) #> 8  8.377 [8, 10] #> 9  1.086  [0, 2) #> 10 4.495  [4, 6) tab_n(x, 4) #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 tab_width(x, 2) #> [1.086, 3.086) [3.086, 5.086) [5.086, 7.086) [7.086, 9.086) [9.086, 11.09]  #>              1              4              2              2              1 tab_evenly(x, 5) #>  [1.086, 2.81)  [2.81, 4.535) [4.535, 6.259) [6.259, 7.983) [7.983, 9.708]  #>              1              2              2              2              3 tab_mean_sd(x) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              1              4              3              2"},{"path":"/articles/santoku.html","id":"specifying-labels","dir":"Articles","previous_headings":"","what":"Specifying labels","title":"Introduction to santoku","text":"default, santoku labels intervals using mathematical notation: [0, 1] means numbers 0 1 inclusive. (0, 1) means numbers strictly 0 1, including endpoints. [0, 1) means numbers 0 1, including 0 1. (0, 1] means numbers 0 1, including 1 0. {0} means just number 0. override labels, provide names breaks argument: , can specify factor labels labels argument: need many labels intervals - one fewer length(breaks) data doesn’t extend beyond breaks, one length(breaks) . label intervals dash, use lbl_dash(): label integer data, use lbl_discrete(). uses informative right endpoints: can customize first last labels: label intervals order use lbl_seq(): can use numerals even roman numerals: labelling functions include: lbl_endpoints() - use left endpoints labels lbl_midpoints() - use interval midpoints labels lbl_glue() - specify labels flexibly glue package","code":"chopped <- chop(x, c(Lowest = 1, Low = 2, Higher = 5, Highest = 8)) data.frame(x, chopped) #>        x chopped #> 1  4.978     Low #> 2  8.970 Highest #> 3  3.392     Low #> 4  4.677     Low #> 5  7.057  Higher #> 6  9.708 Highest #> 7  6.714  Higher #> 8  8.377 Highest #> 9  1.086  Lowest #> 10 4.495     Low chopped <- chop(x, c(2, 5, 8), labels = c(\"Lowest\", \"Low\", \"Higher\", \"Highest\")) data.frame(x, chopped) #>        x chopped #> 1  4.978     Low #> 2  8.970 Highest #> 3  3.392     Low #> 4  4.677     Low #> 5  7.057  Higher #> 6  9.708 Highest #> 7  6.714  Higher #> 8  8.377 Highest #> 9  1.086  Lowest #> 10 4.495     Low chopped <- chop(x, c(2, 5, 8), labels = lbl_dash()) data.frame(x, chopped) #>        x chopped #> 1  4.978     2—5 #> 2  8.970 8—9.708 #> 3  3.392     2—5 #> 4  4.677     2—5 #> 5  7.057     5—8 #> 6  9.708 8—9.708 #> 7  6.714     5—8 #> 8  8.377 8—9.708 #> 9  1.086 1.086—2 #> 10 4.495     2—5 chopped  <- chop(1:10, c(2, 5, 8), labels = lbl_discrete()) chopped2 <- chop(1:10, c(2, 5, 8), labels = lbl_dash()) data.frame(x = 1:10, lbl_discrete = chopped, lbl_dash = chopped2) #>     x lbl_discrete lbl_dash #> 1   1            1      1—2 #> 2   2          2—4      2—5 #> 3   3          2—4      2—5 #> 4   4          2—4      2—5 #> 5   5          5—7      5—8 #> 6   6          5—7      5—8 #> 7   7          5—7      5—8 #> 8   8         8—10     8—10 #> 9   9         8—10     8—10 #> 10 10         8—10     8—10 chopped <- chop(x, c(2, 5, 8), labels = lbl_dash(first = \"< 2\", last = \"8+\")) data.frame(x, chopped) #>        x chopped #> 1  4.978     2—5 #> 2  8.970      8+ #> 3  3.392     2—5 #> 4  4.677     2—5 #> 5  7.057     5—8 #> 6  9.708      8+ #> 7  6.714     5—8 #> 8  8.377      8+ #> 9  1.086     < 2 #> 10 4.495     2—5 chopped <- chop(x, c(2, 5, 8), labels = lbl_seq()) data.frame(x, chopped) #>        x chopped #> 1  4.978       b #> 2  8.970       d #> 3  3.392       b #> 4  4.677       b #> 5  7.057       c #> 6  9.708       d #> 7  6.714       c #> 8  8.377       d #> 9  1.086       a #> 10 4.495       b chop(x, c(2, 5, 8), labels = lbl_seq(\"(1)\")) #>  [1] (2) (4) (2) (2) (3) (4) (3) (4) (1) (2) #> Levels: (1) (2) (3) (4) chop(x, c(2, 5, 8), labels = lbl_seq(\"i.\")) #>  [1] ii.  iv.  ii.  ii.  iii. iv.  iii. iv.  i.   ii.  #> Levels: i. ii. iii. iv."},{"path":"/articles/santoku.html","id":"specifying-breaks","dir":"Articles","previous_headings":"","what":"Specifying breaks","title":"Introduction to santoku","text":"default, chop() extends breaks necessary. don’t want , set extend = FALSE: Data outside range breaks become NA. default, intervals closed left, .e. include left endpoints. want right-closed intervals, set left = FALSE: default, last interval closed ends. want keep last interval open end, set close_end = FALSE:","code":"chopped <- chop(x, c(3, 5, 7), extend = FALSE) data.frame(x, chopped) #>        x chopped #> 1  4.978  [3, 5) #> 2  8.970    <NA> #> 3  3.392  [3, 5) #> 4  4.677  [3, 5) #> 5  7.057    <NA> #> 6  9.708    <NA> #> 7  6.714  [5, 7] #> 8  8.377    <NA> #> 9  1.086    <NA> #> 10 4.495  [3, 5) y <- 1:5 data.frame(         y = y,          left_closed = chop(y, 1:5),          right_closed = chop(y, 1:5, left = FALSE)       ) #>   y left_closed right_closed #> 1 1      [1, 2)       [1, 2] #> 2 2      [2, 3)       [1, 2] #> 3 3      [3, 4)       (2, 3] #> 4 4      [4, 5]       (3, 4] #> 5 5      [4, 5]       (4, 5] data.frame(   y = y,   end_closed = chop(y, 1:5),   end_open   = chop(y, 1:5, close_end = FALSE) ) #>   y end_closed end_open #> 1 1     [1, 2)   [1, 2) #> 2 2     [2, 3)   [2, 3) #> 3 3     [3, 4)   [3, 4) #> 4 4     [4, 5]   [4, 5) #> 5 5     [4, 5]      {5}"},{"path":"/articles/santoku.html","id":"chopping-dates-times-and-other-vectors","dir":"Articles","previous_headings":"","what":"Chopping dates, times and other vectors","title":"Introduction to santoku","text":"can chop many kinds vectors santoku, including Date objects… … POSIXct (date-time) objects: Note santoku correctly handles different timezones. can use chop_width() objects lubridate package, chop irregular periods months: can format labels using format strings strptime(). lbl_discrete() useful : can also chop vectors units, using units package: able chop anything comparison operator. can even chop character data using lexical ordering. default santoku emits warning case, avoid accidentally misinterpreting results: find type data can’t chop, please file issue.","code":"y2k <- as.Date(\"2000-01-01\") + 0:10 * 7 data.frame(   y2k = y2k,   chopped = chop(y2k, as.Date(c(\"2000-02-01\", \"2000-03-01\"))) ) #>           y2k                  chopped #> 1  2000-01-01 [2000-01-01, 2000-02-01) #> 2  2000-01-08 [2000-01-01, 2000-02-01) #> 3  2000-01-15 [2000-01-01, 2000-02-01) #> 4  2000-01-22 [2000-01-01, 2000-02-01) #> 5  2000-01-29 [2000-01-01, 2000-02-01) #> 6  2000-02-05 [2000-02-01, 2000-03-01) #> 7  2000-02-12 [2000-02-01, 2000-03-01) #> 8  2000-02-19 [2000-02-01, 2000-03-01) #> 9  2000-02-26 [2000-02-01, 2000-03-01) #> 10 2000-03-04 [2000-03-01, 2000-03-11] #> 11 2000-03-11 [2000-03-01, 2000-03-11] # hours of the 2020 Crew Dragon flight: crew_dragon <- seq(as.POSIXct(\"2020-05-30 18:00\", tz = \"GMT\"),                       length.out = 24, by = \"hours\") liftoff <- as.POSIXct(\"2020-05-30 15:22\", tz = \"America/New_York\") dock    <- as.POSIXct(\"2020-05-31 10:16\", tz = \"America/New_York\")  data.frame(   crew_dragon = crew_dragon,   chopped = chop(crew_dragon, c(liftoff, dock),                     labels = c(\"pre-flight\", \"flight\", \"docked\")) ) #> Warning in .check_tzones(e1, e2): 'tzone' attributes are inconsistent  #> Warning in .check_tzones(e1, e2): 'tzone' attributes are inconsistent #>            crew_dragon    chopped #> 1  2020-05-30 18:00:00 pre-flight #> 2  2020-05-30 19:00:00 pre-flight #> 3  2020-05-30 20:00:00     flight #> 4  2020-05-30 21:00:00     flight #> 5  2020-05-30 22:00:00     flight #> 6  2020-05-30 23:00:00     flight #> 7  2020-05-31 00:00:00     flight #> 8  2020-05-31 01:00:00     flight #> 9  2020-05-31 02:00:00     flight #> 10 2020-05-31 03:00:00     flight #> 11 2020-05-31 04:00:00     flight #> 12 2020-05-31 05:00:00     flight #> 13 2020-05-31 06:00:00     flight #> 14 2020-05-31 07:00:00     flight #> 15 2020-05-31 08:00:00     flight #> 16 2020-05-31 09:00:00     flight #> 17 2020-05-31 10:00:00     flight #> 18 2020-05-31 11:00:00     flight #> 19 2020-05-31 12:00:00     flight #> 20 2020-05-31 13:00:00     flight #> 21 2020-05-31 14:00:00     flight #> 22 2020-05-31 15:00:00     docked #> 23 2020-05-31 16:00:00     docked #> 24 2020-05-31 17:00:00     docked library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union data.frame(   y2k = y2k,   chopped = chop_width(y2k, months(1)) ) #>           y2k                  chopped #> 1  2000-01-01 [2000-01-01, 2000-02-01) #> 2  2000-01-08 [2000-01-01, 2000-02-01) #> 3  2000-01-15 [2000-01-01, 2000-02-01) #> 4  2000-01-22 [2000-01-01, 2000-02-01) #> 5  2000-01-29 [2000-01-01, 2000-02-01) #> 6  2000-02-05 [2000-02-01, 2000-03-01) #> 7  2000-02-12 [2000-02-01, 2000-03-01) #> 8  2000-02-19 [2000-02-01, 2000-03-01) #> 9  2000-02-26 [2000-02-01, 2000-03-01) #> 10 2000-03-04 [2000-03-01, 2000-04-01) #> 11 2000-03-11 [2000-03-01, 2000-04-01) data.frame(   y2k = y2k,   chopped = chop_width(y2k, months(1), labels = lbl_discrete(fmt = \"%e %b\")) ) #>           y2k       chopped #> 1  2000-01-01  1 Jan—31 Jan #> 2  2000-01-08  1 Jan—31 Jan #> 3  2000-01-15  1 Jan—31 Jan #> 4  2000-01-22  1 Jan—31 Jan #> 5  2000-01-29  1 Jan—31 Jan #> 6  2000-02-05  1 Feb—29 Feb #> 7  2000-02-12  1 Feb—29 Feb #> 8  2000-02-19  1 Feb—29 Feb #> 9  2000-02-26  1 Feb—29 Feb #> 10 2000-03-04  1 Mar—31 Mar #> 11 2000-03-11  1 Mar—31 Mar library(units) #> udunits database from /Library/Frameworks/R.framework/Versions/4.3-arm64/Resources/library/units/share/udunits/udunits2.xml  x <- set_units(1:10 * 10, cm) br <- set_units(1:3, ft) data.frame(   x = x,   chopped = chop(x, br) ) #>           x                    chopped #> 1   10 [cm] [ 10.00 [cm],  30.48 [cm]) #> 2   20 [cm] [ 10.00 [cm],  30.48 [cm]) #> 3   30 [cm] [ 10.00 [cm],  30.48 [cm]) #> 4   40 [cm] [ 30.48 [cm],  60.96 [cm]) #> 5   50 [cm] [ 30.48 [cm],  60.96 [cm]) #> 6   60 [cm] [ 30.48 [cm],  60.96 [cm]) #> 7   70 [cm] [ 60.96 [cm],  91.44 [cm]) #> 8   80 [cm] [ 60.96 [cm],  91.44 [cm]) #> 9   90 [cm] [ 60.96 [cm],  91.44 [cm]) #> 10 100 [cm] [ 91.44 [cm], 100.00 [cm]] chop(letters[1:10], c(\"d\", \"f\")) #> Warning in categorize_non_numeric(x, breaks, left): `x` or `breaks` is of type #> character, using lexical sorting. To turn off this warning, run: #> options(santoku.warn_character = FALSE) #>  [1] [a, d) [a, d) [a, d) [d, f) [d, f) [f, j] [f, j] [f, j] [f, j] [f, j] #> Levels: [a, d) [d, f) [f, j]"},{"path":"/articles/website-articles/performance.html","id":"speed","dir":"Articles > Website-articles","previous_headings":"","what":"Speed","title":"Performance","text":"core santoku written C++. reasonably fast:","code":"packageVersion(\"santoku\") #> [1] '0.10.0' set.seed(27101975)  mb <- bench::mark(         santoku::chop(rnorm(1e5), -2:2),         base::cut(rnorm(1e5), -2:2),         Hmisc::cut2(rnorm(1e5), -2:2),         min_iterations = 100,         check = FALSE       ) mb #> # A tibble: 3 × 6 #>   expression                            min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                        <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(rnorm(1e+05), -2:2)  8.43ms  8.87ms     111.    15.13MB     50.1 #> 2 base::cut(rnorm(1e+05), -2:2)      4.32ms  4.47ms     222.     3.49MB     20.4 #> 3 Hmisc::cut2(rnorm(1e+05), -2:2)   12.74ms 13.65ms      73.1   26.23MB    108. autoplot(mb, type = \"violin\") #> Loading required namespace: tidyr"},{"path":"/articles/website-articles/performance.html","id":"dates","dir":"Articles > Website-articles","previous_headings":"","what":"Dates","title":"Performance","text":"","code":"dates <- sample(as.Date(\"2000-01-01\") + 0:364, 1e5, replace = TRUE) break_dates <- as.Date(\"2000-01-01\") + c(60, 120, 180)  mb_dates <- bench::mark(               santoku::chop(dates, break_dates),               base::cut(dates, break_dates),               Hmisc::cut2(dates, break_dates),               min_iterations = 100,               check = FALSE             )  mb_dates #> # A tibble: 3 × 6 #>   expression                             min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                        <bch:tm> <bch:>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(dates, break_dates)   5.49ms 5.95ms      168.   10.62MB     90.4 #> 2 base::cut(dates, break_dates)       2.88ms 3.03ms      329.    3.91MB     31.6 #> 3 Hmisc::cut2(dates, break_dates)     5.21ms 5.48ms      181.   15.35MB     93.1 autoplot(mb_dates, type = \"violin\")"},{"path":"/articles/website-articles/performance.html","id":"cutting-characters-pure-r-implementation","dir":"Articles > Website-articles","previous_headings":"","what":"Cutting characters (pure R implementation)","title":"Performance","text":"","code":"oo <- options(santoku.warn_character = FALSE)   lipsum <- stringi::stri_rand_lipsum(100)  mb_pure_r <- bench::mark(                santoku::chop(lipsum, letters),                santoku::chop(seq(1, 26, length = 100), 1:26),                min_iterations = 100,                check = FALSE              )  mb_pure_r #> # A tibble: 2 × 6 #>   expression                             min median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                           <bch> <bch:>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(lipsum, letters)       817µs  854µs     1154.   132.6KB     17.2 #> 2 santoku::chop(seq(1, 26, length = 1… 413µs  426µs     2305.    39.4KB     30.4  options(oo) autoplot(mb_pure_r, type = \"violin\")"},{"path":"/articles/website-articles/performance.html","id":"many-breaks","dir":"Articles > Website-articles","previous_headings":"","what":"Many breaks","title":"Performance","text":"","code":"many_breaks <- seq(-2, 2, 0.001)  mb_breaks <- bench::mark(         santoku::chop(rnorm(1e4), many_breaks),         base::cut(rnorm(1e4), many_breaks),         Hmisc::cut2(rnorm(1e4), many_breaks),         min_iterations = 100,         check = FALSE       )  mb_breaks #> # A tibble: 3 × 6 #>   expression                            min  median `itr/sec` mem_alloc `gc/sec` #>   <bch:expr>                        <bch:t> <bch:t>     <dbl> <bch:byt>    <dbl> #> 1 santoku::chop(rnorm(10000), many… 22.77ms 23.27ms      42.8    5.11MB     4.75 #> 2 base::cut(rnorm(10000), many_bre…  3.44ms  3.59ms     278.     1.54MB    10.6  #> 3 Hmisc::cut2(rnorm(10000), many_b…  9.76ms  10.2ms      98.1     6.2MB    16.0 autoplot(mb_breaks, type = \"violin\")"},{"path":"/articles/whats-new-in-0-9-0.html","id":"you-can-use-break-names-for-labels","dir":"Articles","previous_headings":"","what":"You can use break names for labels","title":"What's new in santoku 0.9.0","text":"command line, sometimes ’d like quickly add labels breaks. Now, can simply adding names breaks vector: Break names override labels argument, can still use unnamed breaks: Names can also used labels chop_quantiles() chop_proportions(): feature experimental now.","code":"library(santoku)  chop(1:5, c(1,3,5)) #> [1] [1, 3) [1, 3) [3, 5] [3, 5] [3, 5] #> Levels: [1, 3) [3, 5]  chop(1:5, c(Low = 1, High = 3, 5)) #> [1] Low  Low  High High High #> Levels: Low High ages <- sample(12:80, 20) tab(ages,        c(\"Under 16\" = 0, 16, 25, 35, 45, 55, \"65 and over\" = 65),        labels = lbl_discrete()     ) #>    Under 16       16—24       25—34       35—44       45—54       55—64  #>           1           1           2           3           3           4  #> 65 and over  #>           6 x <- rnorm(10) chopped <- chop_quantiles(x,                              c(\"Lower tail\" = 0, 0.025, \"Upper tail\" = 0.975)                           ) data.frame(x, chopped) #>             x       chopped #> 1  -1.3888607 [2.5%, 97.5%) #> 2  -0.2787888 [2.5%, 97.5%) #> 3  -0.1333213 [2.5%, 97.5%) #> 4   0.6359504 [2.5%, 97.5%) #> 5  -0.2842529 [2.5%, 97.5%) #> 6  -2.6564554    Lower tail #> 7  -2.4404669 [2.5%, 97.5%) #> 8   1.3201133    Upper tail #> 9  -0.3066386 [2.5%, 97.5%) #> 10 -1.7813084 [2.5%, 97.5%)"},{"path":"/articles/whats-new-in-0-9-0.html","id":"close_end-works-differently","dir":"Articles","previous_headings":"","what":"close_end works differently","title":"What's new in santoku 0.9.0","text":"close_end parameter used right-close last break. used applied breaks extended cover items beyond explicitly given breaks. think confusing users. now, close_end applied breaks extended - .e. last break. 0.8.0: Notice central break [2, 3] right-closed. (extended break [3, 4] right-closed , extended breaks always closed “outer” end.) 0.9.0: Now, close_end applied final, extended break [3, 4], explicit break [2, 3).","code":"chop(1:4, 2:3, close_end = TRUE) #> [1] [1, 2) [2, 3] [2, 3] (3, 4] #> Levels: [1, 2) [2, 3] (3, 4] chop(1:4, 2:3, close_end = TRUE) #> [1] [1, 2) [2, 3) [3, 4] [3, 4] #> Levels: [1, 2) [2, 3) [3, 4]"},{"path":"/articles/whats-new-in-0-9-0.html","id":"close_end-is-true-by-default","dir":"Articles","previous_headings":"","what":"close_end is TRUE by default","title":"What's new in santoku 0.9.0","text":"think exploratory work, users typically want include data lowest highest break, inclusive. , close_end now TRUE default. 0.8.0: 0.9.0:","code":"chop(1:3, 2:3) #> [1] [1, 2) [2, 3) {3}    #> Levels: [1, 2) [2, 3) {3} chop(1:3, 2:3) #> [1] [1, 2) [2, 3] [2, 3] #> Levels: [1, 2) [2, 3]"},{"path":"/articles/whats-new-in-0-9-0.html","id":"new-raw-parameter-for-chop","dir":"Articles","previous_headings":"","what":"New raw parameter for chop()","title":"What's new in santoku 0.9.0","text":"lbl_* functions raw parameter use raw interval endpoints labels, rather e.g. percentiles standard deviations. ’ve moved main chop() function. makes easier use: raw parameter lbl_* functions deprecated.","code":"chop_mean_sd(x) #>  [1] [-1 sd, 0 sd)  [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [0 sd, 1 sd)   #>  [6] [-2 sd, -1 sd) [-2 sd, -1 sd) [1 sd, 2 sd)   [0 sd, 1 sd)   [-1 sd, 0 sd)  #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  chop_mean_sd(x, raw = TRUE) #>  [1] [-2.03, -0.7314)  [-0.7314, 0.5674) [-0.7314, 0.5674) [0.5674, 1.866)   #>  [5] [-0.7314, 0.5674) [-3.329, -2.03)   [-3.329, -2.03)   [0.5674, 1.866)   #>  [9] [-0.7314, 0.5674) [-2.03, -0.7314)  #> 4 Levels: [-3.329, -2.03) [-2.03, -0.7314) ... [0.5674, 1.866)"},{"path":"/articles/whats-new-in-0-9-0.html","id":"other-changes","dir":"Articles","previous_headings":"","what":"Other changes","title":"What's new in santoku 0.9.0","text":"NEWS file lists changes, including new chop_fn() function creates breaks using arbitrary function.","code":""},{"path":"/articles/whats-new-in-0-9-0.html","id":"feedback","dir":"Articles","previous_headings":"","what":"Feedback","title":"What's new in santoku 0.9.0","text":"expect last release 1.0, ’ll stabilize interface move santoku “experimental” “stable”. , problems suggestions regarding changes, please file issue.","code":""},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Hugh-Jones. Author, maintainer. Daniel Possenriede. Contributor.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hugh-Jones D (2023). santoku: Versatile Cutting Tool. https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/.","code":"@Manual{,   title = {santoku: A Versatile Cutting Tool},   author = {David Hugh-Jones},   year = {2023},   note = {https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/}, }"},{"path":"/index.html","id":"santoku-","dir":"","previous_headings":"","what":"A Versatile Cutting Tool","title":"A Versatile Cutting Tool","text":"santoku versatile cutting tool R. provides chop(), replacement base::cut().","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"A Versatile Cutting Tool","text":"Install r-universe: CRAN: get development version github:","code":"install.packages(\"santoku\", repos = c(\"https://hughjonesd.r-universe.dev\",                                        \"https://cloud.r-project.org\")) install.packages(\"santoku\") # install.packages(\"remotes\") remotes::install_github(\"hughjonesd/santoku\")"},{"path":"/index.html","id":"advantages","dir":"","previous_headings":"","what":"Advantages","title":"A Versatile Cutting Tool","text":"advantages santoku: default, chop() always covers whole range data, won’t get unexpected NA values. chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. chop() can handle many kinds data, including numbers, dates times, units. chop_* functions create intervals many ways, using quantiles data, standard deviations, fixed-width intervals, equal-sized groups, pretty intervals use graphs. ’s easy label intervals: use names breaks vector, use lbl_* function create interval notation like [1, 2), dash notation like 1-2, arbitrary styles using glue::glue(). tab_* functions quickly chop data, tabulate . advantages make santoku especially useful exploratory analysis, may know range data advance.","code":""},{"path":"/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"A Versatile Cutting Tool","text":"chop returns factor: Include number twice match exactly: Use names breaks labels: use lbl_* functions: Chop fixed-width intervals: fixed-size groups: Chop dates calendar month, tabulate: information, see vignette.","code":"library(santoku) chop(1:5, c(2, 4)) #> [1] [1, 2) [2, 4) [2, 4) [4, 5] [4, 5] #> Levels: [1, 2) [2, 4) [4, 5] chop(1:5, c(2, 2, 4)) #> [1] [1, 2) {2}    (2, 4) [4, 5] [4, 5] #> Levels: [1, 2) {2} (2, 4) [4, 5] chop(1:5, c(Low = 1, Mid = 2, High = 4)) #> [1] Low  Mid  Mid  High High #> Levels: Low Mid High chop(1:5, c(2, 4), labels = lbl_dash()) #> [1] 1—2 2—4 2—4 4—5 4—5 #> Levels: 1—2 2—4 4—5 chop_width(runif(10), 0.1) #>  [1] [0.1399, 0.2399) [0.5399, 0.6399) [0.5399, 0.6399) [0.5399, 0.6399) #>  [5] [0.6399, 0.7399) [0.3399, 0.4399) [0.8399, 0.9399] [0.8399, 0.9399] #>  [9] [0.5399, 0.6399) [0.1399, 0.2399) #> 5 Levels: [0.1399, 0.2399) [0.3399, 0.4399) ... [0.8399, 0.9399] chop_n(1:10, 5) #>  [1] [1, 6)  [1, 6)  [1, 6)  [1, 6)  [1, 6)  [6, 10] [6, 10] [6, 10] [6, 10] #> [10] [6, 10] #> Levels: [1, 6) [6, 10] library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union  dates <- as.Date(\"2021-12-31\") + 1:90  tab_width(dates, months(1), labels = lbl_discrete(fmt = \"%d %b\")) #> 01 Jan—31 Jan 01 Feb—28 Feb 01 Mar—31 Mar  #>            31            28            31"},{"path":"/reference/breaks-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class representing a set of intervals — breaks-class","title":"Class representing a set of intervals — breaks-class","text":"Class representing set intervals","code":""},{"path":"/reference/breaks-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class representing a set of intervals — breaks-class","text":"","code":"# S3 method for breaks format(x, ...)  # S3 method for breaks print(x, ...)  is.breaks(x, ...)"},{"path":"/reference/breaks-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class representing a set of intervals — breaks-class","text":"x breaks object ... Unused","code":""},{"path":[]},{"path":"/reference/brk-left-right.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"brk_left(breaks)  brk_right(breaks)"},{"path":"/reference/brk-left-right.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left- or right-closed breaks — brk-left-right","text":"breaks numeric vector.","code":""},{"path":"/reference/brk-left-right.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left- or right-closed breaks — brk-left-right","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk-left-right.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Left- or right-closed breaks — brk-left-right","text":"functions \"questioning\" stage clash left argument chop() friends. functions override left argument chop().","code":""},{"path":"/reference/brk-left-right.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"chop(5:7, brk_left(5:7)) #> Warning: `brk_left()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_warnings()` to see where this warning was generated. #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}  chop(5:7, brk_right(5:7)) #> Warning: `brk_right()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_warnings()` to see where this warning was generated. #> Warning: `left` argument to `brk_right()` ignored #> [1] {5}    (5, 6] (6, 7] #> Levels: {5} (5, 6] (6, 7]  chop(5:7, brk_left(5:7)) #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}"},{"path":"/reference/brk_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a standard set of breaks — brk_default","title":"Create a standard set of breaks — brk_default","text":"Create standard set breaks","code":""},{"path":"/reference/brk_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a standard set of breaks — brk_default","text":"","code":"brk_default(breaks)"},{"path":"/reference/brk_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a standard set of breaks — brk_default","text":"breaks numeric vector.","code":""},{"path":"/reference/brk_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a standard set of breaks — brk_default","text":"function returns object class breaks.","code":""},{"path":"/reference/brk_default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a standard set of breaks — brk_default","text":"","code":"chop(1:10, c(2, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10] chop(1:10, brk_default(c(2, 5, 8))) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10]"},{"path":"/reference/brk_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Create breaks using an existing function — brk_fn","title":"Create breaks using an existing function — brk_fn","text":"brk_fn() convenience wrapper: chop(x, brk_fn(foo, ...)) chop(x, foo(x, ...)).","code":""},{"path":"/reference/brk_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create breaks using an existing function — brk_fn","text":"","code":"brk_fn(fn, ...)"},{"path":"/reference/brk_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create breaks using an existing function — brk_fn","text":"fn function returns numeric vector breaks. ... arguments fn","code":""},{"path":"/reference/brk_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create breaks using an existing function — brk_fn","text":"function returns object class breaks.","code":""},{"path":"/reference/brk_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create breaks using an existing function — brk_fn","text":"","code":"if (requireNamespace(\"scales\")) {   chop(rlnorm(10), brk_fn(scales::breaks_log(5)))   # same as   # x <- rlnorm(10)   # chop(x, scales::breaks_log(5)(x)) } #> Loading required namespace: scales #>  [1] [2, 3)   [2, 3)   [1, 2)   [1, 2)   [1, 2)   [1, 2)   [0.5, 1) [3, 5]   #>  [9] [1, 2)   [3, 5]   #> Levels: [0.5, 1) [1, 2) [2, 3) [3, 5]"},{"path":"/reference/brk_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a breaks object manually — brk_manual","title":"Create a breaks object manually — brk_manual","text":"Create breaks object manually","code":""},{"path":"/reference/brk_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a breaks object manually — brk_manual","text":"","code":"brk_manual(breaks, left_vec)"},{"path":"/reference/brk_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a breaks object manually — brk_manual","text":"breaks vector, must sorted. left_vec logical vector, length breaks. Specifies whether break left-closed right-closed.","code":""},{"path":"/reference/brk_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a breaks object manually — brk_manual","text":"function returns object class breaks.","code":""},{"path":"/reference/brk_manual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a breaks object manually — brk_manual","text":"breaks must closed exactly one side, like ..., x) [x, ... (left-closed) ..., x) [x, ... (right-closed). example, breaks = 1:3 left = c(TRUE, FALSE, TRUE), resulting intervals Singleton breaks created repeating number breaks. Singletons must closed sides, repeated number indices , +1, left[] must TRUE left[+1] must FALSE.","code":"T        F       T [ 1,  2 ] ( 2, 3 )"},{"path":"/reference/brk_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a breaks object manually — brk_manual","text":"","code":"lbrks <- brk_manual(1:3, rep(TRUE, 3)) chop(1:3, lbrks, extend = FALSE) #> Warning: Ignoring `close_end` with `brk_manual()` #> [1] [1, 2) [2, 3] [2, 3] #> Levels: [1, 2) [2, 3]  rbrks <- brk_manual(1:3, rep(FALSE, 3)) chop(1:3, rbrks, extend = FALSE) #> Warning: Ignoring `close_end` with `brk_manual()` #> [1] <NA>   (1, 2] (2, 3] #> Levels: (1, 2] (2, 3]  brks_singleton <- brk_manual(       c(1,    2,    2,     3),       c(TRUE, TRUE, FALSE, TRUE))  chop(1:3, brks_singleton, extend = FALSE) #> Warning: Ignoring `close_end` with `brk_manual()` #> [1] [1, 2) {2}    (2, 3] #> Levels: [1, 2) {2} (2, 3]"},{"path":"/reference/brk_width-for-datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"brk_width() can used time interval classes base R lubridate package.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"# S3 method for Duration brk_width(width, start)"},{"path":"/reference/brk_width-for-datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width scalar difftime, Period Duration object. start scalar class Date POSIXct. Can omitted.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width Period, lubridate::add_with_rollback() used calculate widths. can useful e.g. calendar months.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"if (requireNamespace(\"lubridate\")) {   year2001 <- as.Date(\"2001-01-01\") + 0:364   tab_width(year2001, months(1),         labels = lbl_discrete(\" to \", fmt = \"%e %b %y\")) } #>  1 Jan 01 to 31 Jan 01  1 Feb 01 to 28 Feb 01  1 Mar 01 to 31 Mar 01  #>                     31                     28                     31  #>  1 Apr 01 to 30 Apr 01  1 May 01 to 31 May 01  1 Jun 01 to 30 Jun 01  #>                     30                     31                     30  #>  1 Jul 01 to 31 Jul 01  1 Aug 01 to 31 Aug 01  1 Sep 01 to 30 Sep 01  #>                     31                     31                     30  #>  1 Oct 01 to 31 Oct 01  1 Nov 01 to 30 Nov 01  1 Dec 01 to 31 Dec 01  #>                     31                     30                     31"},{"path":"/reference/chop.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut data into intervals — chop","title":"Cut data into intervals — chop","text":"chop() cuts x intervals. returns factor length x, representing interval contains element x. kiru() alias chop. tab() calls chop() returns contingency table() result.","code":""},{"path":"/reference/chop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut data into intervals — chop","text":"","code":"chop(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = TRUE,   raw = NULL,   drop = TRUE )  kiru(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = TRUE,   raw = NULL,   drop = TRUE )  tab(   x,   breaks,   labels = lbl_intervals(),   extend = NULL,   left = TRUE,   close_end = TRUE,   raw = NULL,   drop = TRUE )"},{"path":"/reference/chop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut data into intervals — chop","text":"x vector. breaks numeric vector cut-points function create cut-points x. labels character vector labels function create labels. extend Logical. TRUE, always extend breaks +/-Inf. NULL, extend breaks min(x) /max(x) necessary. NULL, never extend. left Logical. Left-closed right-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) raw Logical. Use raw values labels? drop Logical. Drop unused levels result?","code":""},{"path":"/reference/chop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut data into intervals — chop","text":"chop() returns factor length x, representing intervals containing value x. tab() returns contingency table().","code":""},{"path":"/reference/chop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut data into intervals — chop","text":"x may numeric vector, generally, vector can compared < == (see Ops). particular Date date-time objects supported. Character vectors supported warning.","code":""},{"path":"/reference/chop.html","id":"breaks","dir":"Reference","previous_headings":"","what":"Breaks","title":"Cut data into intervals — chop","text":"breaks may vector function. vector, breaks gives break endpoints. Repeated values create singleton intervals. example breaks = c(1, 3, 3, 5) creates 3 intervals: [1, 3), {3} (3, 5]. breaks function, called x, extend, left close_end arguments, return object class breaks. Use brk_* functions create variety data-dependent breaks. Names breaks may used labels. See \"Labels\" .","code":""},{"path":"/reference/chop.html","id":"options-for-breaks","dir":"Reference","previous_headings":"","what":"Options for breaks","title":"Cut data into intervals — chop","text":"default, left-closed intervals created. left FALSE, right-closed intervals created. close_end TRUE final break (first break left FALSE) closed ends. guarantees values x min(breaks) <= x <= max(breaks) included intervals. version 0.9.0, close_end FALSE default, also behaved differently respect extended breaks: see \"Extending intervals\" . Using mathematical set notation: left TRUE close_end TRUE, breaks look like [b1, b2), [b2, b3) ... [b_n-1, b_n]. left FALSE close_end TRUE, breaks look like [b1, b2], (b2, b3] ... (b_n-1, b_n]. left TRUE close_end FALSE, breaks look like ...[b1, b2) .... left FALSE close_end FALSE, breaks look like ...(b1, b2] ....","code":""},{"path":"/reference/chop.html","id":"extending-intervals","dir":"Reference","previous_headings":"","what":"Extending intervals","title":"Cut data into intervals — chop","text":"extend TRUE, intervals extended [-Inf, min(breaks)) (max(breaks), Inf]. extend NULL (default), intervals extended [min(x), min(breaks)) (max(breaks), max(x)], necessary -- .e. elements x unextended breaks. close_end applied breaks extended, .e. always last first break. change previous behaviour. version 0.8.0, close_end applied user-specified intervals, extend applied. Note breaks extended, extended break always closed anyway.","code":""},{"path":"/reference/chop.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Cut data into intervals — chop","text":"labels may character vector. length (possibly extended) number intervals. Alternatively, labels may lbl_* function lbl_seq(). breaks named vector, non-zero-length names breaks used labels interval starting corresponding element. overrides labels argument (unnamed breaks still use labels). feature . labels NULL, integer codes returned instead factor. raw TRUE, labels show actual numbers calculated breaks. raw FALSE labels may show objects, quantiles chop_quantiles() friends, proportions range chop_proportions(), standard deviations chop_mean_sd(). raw NULL lbl_* functions use default (usually FALSE). Otherwise, raw argument chop() overrides raw arguments passed lbl_* functions directly.","code":""},{"path":"/reference/chop.html","id":"miscellaneous","dir":"Reference","previous_headings":"","what":"Miscellaneous","title":"Cut data into intervals — chop","text":"NA values x, values outside extended endpoints, return NA. kiru() synonym chop(). load {tidyr}, can use avoid confusion tidyr::chop(). Note chop(), like R, uses binary arithmetic. Thus, numbers may exactly equal think . example .","code":""},{"path":[]},{"path":"/reference/chop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut data into intervals — chop","text":"","code":"chop(1:7, c(2, 4, 6)) #> [1] [1, 2) [2, 4) [2, 4) [4, 6) [4, 6) [6, 7] [6, 7] #> Levels: [1, 2) [2, 4) [4, 6) [6, 7]  chop(1:7, c(2, 4, 6), extend = FALSE) #> [1] <NA>   [2, 4) [2, 4) [4, 6] [4, 6] [4, 6] <NA>   #> Levels: [2, 4) [4, 6]  # Repeat a number for a singleton break: chop(1:7, c(2, 4, 4, 6)) #> [1] [1, 2) [2, 4) [2, 4) {4}    (4, 6) [6, 7] [6, 7] #> Levels: [1, 2) [2, 4) {4} (4, 6) [6, 7]  chop(1:7, c(2, 4, 6), left = FALSE) #> [1] [1, 2] [1, 2] (2, 4] (2, 4] (4, 6] (4, 6] (6, 7] #> Levels: [1, 2] (2, 4] (4, 6] (6, 7]  chop(1:7, c(2, 4, 6), close_end = FALSE) #> [1] [1, 2) [2, 4) [2, 4) [4, 6) [4, 6) [6, 7] [6, 7] #> Levels: [1, 2) [2, 4) [4, 6) [6, 7]  chop(1:7, brk_quantiles(c(0.25, 0.75))) #> [1] [0%, 25%)   [0%, 25%)   [25%, 75%)  [25%, 75%)  [25%, 75%)  [75%, 100%] #> [7] [75%, 100%] #> Levels: [0%, 25%) [25%, 75%) [75%, 100%]  # A single break is fine if `extend` is not `FALSE`: chop(1:7, 4) #> [1] [1, 4) [1, 4) [1, 4) [4, 7] [4, 7] [4, 7] [4, 7] #> Levels: [1, 4) [4, 7]  # Floating point inaccuracy: chop(0.3/3, c(0, 0.1, 0.1, 1), labels = c(\"< 0.1\", \"0.1\", \"> 0.1\")) #> [1] < 0.1 #> Levels: < 0.1  # -- Labels --  chop(1:7, c(Lowest = 1, Low = 2, Mid = 4, High = 6)) #> [1] Lowest Low    Low    Mid    Mid    High   High   #> Levels: Lowest Low Mid High  chop(1:7, c(2, 4, 6), labels = c(\"Lowest\", \"Low\", \"Mid\", \"High\")) #> [1] Lowest Low    Low    Mid    Mid    High   High   #> Levels: Lowest Low Mid High  chop(1:7, c(2, 4, 6), labels = lbl_dash()) #> [1] 1—2 2—4 2—4 4—6 4—6 6—7 6—7 #> Levels: 1—2 2—4 4—6 6—7  # Mixing names and other labels: chop(1:7, c(\"<2\" = 1, 2, 4, \">=6\" = 6), labels = lbl_dash()) #> [1] <2  2—4 2—4 4—6 4—6 >=6 >=6 #> Levels: <2 2—4 4—6 >=6  # -- Non-standard types --  chop(as.Date(\"2001-01-01\") + 1:7, as.Date(\"2001-01-04\")) #> [1] [2001-01-02, 2001-01-04) [2001-01-02, 2001-01-04) [2001-01-04, 2001-01-08] #> [4] [2001-01-04, 2001-01-08] [2001-01-04, 2001-01-08] [2001-01-04, 2001-01-08] #> [7] [2001-01-04, 2001-01-08] #> Levels: [2001-01-02, 2001-01-04) [2001-01-04, 2001-01-08]  suppressWarnings(chop(LETTERS[1:7], \"D\")) #> [1] [A, D) [A, D) [A, D) [D, G] [D, G] [D, G] [D, G] #> Levels: [A, D) [D, G]   tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3"},{"path":"/reference/chop_equally.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop equal-sized groups — chop_equally","title":"Chop equal-sized groups — chop_equally","text":"chop_equally() chops x groups equal number elements.","code":""},{"path":"/reference/chop_equally.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop equal-sized groups — chop_equally","text":"","code":"chop_equally(   x,   groups,   ...,   labels = lbl_intervals(),   left = is.numeric(x),   close_end = TRUE,   raw = TRUE )  brk_equally(groups)  tab_equally(x, groups, ..., left = is.numeric(x), raw = TRUE)"},{"path":"/reference/chop_equally.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop equal-sized groups — chop_equally","text":"x vector. groups Number groups. ... Passed chop(). labels character vector labels function create labels. left Logical. Left-closed right-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) raw Logical. Use raw values labels?","code":""},{"path":"/reference/chop_equally.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop equal-sized groups — chop_equally","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_equally.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop equal-sized groups — chop_equally","text":"chop_equally() uses chop_quantiles() hood. x duplicate elements, may get fewer groups requested. , warning emitted. See examples.","code":""},{"path":[]},{"path":"/reference/chop_equally.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop equal-sized groups — chop_equally","text":"","code":"chop_equally(1:10, 5) #>  [1] [1, 2.8)   [1, 2.8)   [2.8, 4.6) [2.8, 4.6) [4.6, 6.4) [4.6, 6.4) #>  [7] [6.4, 8.2) [6.4, 8.2) [8.2, 10]  [8.2, 10]  #> Levels: [1, 2.8) [2.8, 4.6) [4.6, 6.4) [6.4, 8.2) [8.2, 10]  # You can't always guarantee `groups` groups: dupes <- c(1, 1, 1, 2, 3, 4, 4, 4) quantile(dupes, 0:4/4) #>   0%  25%  50%  75% 100%  #>  1.0  1.0  2.5  4.0  4.0  chop_equally(dupes, 4) #> Warning: Fewer than 4 intervals created #> [1] [1, 2.5) [1, 2.5) [1, 2.5) [1, 2.5) [2.5, 4] [2.5, 4] [2.5, 4] [2.5, 4] #> Levels: [1, 2.5) [2.5, 4]"},{"path":"/reference/chop_evenly.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into equal-width intervals — chop_evenly","title":"Chop into equal-width intervals — chop_evenly","text":"chop_evenly() chops x intervals intervals equal width.","code":""},{"path":"/reference/chop_evenly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into equal-width intervals — chop_evenly","text":"","code":"chop_evenly(x, intervals, ..., close_end = TRUE)  brk_evenly(intervals)  tab_evenly(x, intervals, ...)"},{"path":"/reference/chop_evenly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into equal-width intervals — chop_evenly","text":"x vector. intervals Integer: number intervals create. ... Passed chop(). close_end Logical. Close last break right? (left FALSE, close first break left?)","code":""},{"path":"/reference/chop_evenly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into equal-width intervals — chop_evenly","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_evenly.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into equal-width intervals — chop_evenly","text":"chop_evenly() sets close_end = TRUE default.","code":""},{"path":[]},{"path":"/reference/chop_evenly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into equal-width intervals — chop_evenly","text":"","code":"chop_evenly(0:10, 5) #>  [1] [0, 2)  [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] #> [10] [8, 10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]"},{"path":"/reference/chop_fn.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop using an existing function — chop_fn","title":"Chop using an existing function — chop_fn","text":"chop_fn() convenience wrapper: chop_fn(x, foo, ...) chop(x, foo(x, ...)).","code":""},{"path":"/reference/chop_fn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop using an existing function — chop_fn","text":"","code":"chop_fn(   x,   fn,   ...,   extend = NULL,   left = TRUE,   close_end = TRUE,   raw = NULL,   drop = TRUE )  brk_fn(fn, ...)  tab_fn(   x,   fn,   ...,   extend = NULL,   left = TRUE,   close_end = TRUE,   raw = NULL,   drop = TRUE )"},{"path":"/reference/chop_fn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop using an existing function — chop_fn","text":"x vector. fn function returns numeric vector breaks. ... arguments fn extend Logical. TRUE, always extend breaks +/-Inf. NULL, extend breaks min(x) /max(x) necessary. NULL, never extend. left Logical. Left-closed right-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) raw Logical. Use raw values labels? drop Logical. Drop unused levels result?","code":""},{"path":"/reference/chop_fn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop using an existing function — chop_fn","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":[]},{"path":"/reference/chop_fn.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop using an existing function — chop_fn","text":"","code":"if (requireNamespace(\"scales\")) {   chop_fn(rlnorm(10), scales::breaks_log(5))   # same as   # x <- rlnorm(10)   # chop(x, scales::breaks_log(5)(x)) } #> Loading required namespace: scales #>  [1] [0.1, 0.3) [0.5, 1)   [0.1, 0.3) [1, 3]     [0.3, 0.5) [0.5, 1)   #>  [7] [0.3, 0.5) [0.5, 1)   [1, 3]     [1, 3]     #> Levels: [0.1, 0.3) [0.3, 0.5) [0.5, 1) [1, 3]"},{"path":"/reference/chop_mean_sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by standard deviations — chop_mean_sd","title":"Chop by standard deviations — chop_mean_sd","text":"Intervals measured standard deviations either side mean.","code":""},{"path":"/reference/chop_mean_sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(x, sds = 1:3, ..., raw = FALSE, sd = deprecated())  brk_mean_sd(sds = 1:3, sd = deprecated())  tab_mean_sd(x, sds = 1:3, ..., raw = FALSE)"},{"path":"/reference/chop_mean_sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by standard deviations — chop_mean_sd","text":"x vector. sds Positive numeric vector standard deviations. ... Passed chop(). raw Logical. Use raw values labels? sd","code":""},{"path":"/reference/chop_mean_sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by standard deviations — chop_mean_sd","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_mean_sd.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop by standard deviations — chop_mean_sd","text":"version 0.7.0, functions changed specifying sds vector. chop 1, 2 3 standard deviations around mean, write chop_mean_sd(x, sds = 1:3) instead chop_mean_sd(x, sd = 3).","code":""},{"path":[]},{"path":"/reference/chop_mean_sd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(1:10) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  chop(1:10, brk_mean_sd()) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  tab_mean_sd(1:10) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              2              3              3              2"},{"path":"/reference/chop_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into fixed-sized groups — chop_n","title":"Chop into fixed-sized groups — chop_n","text":"chop_n() creates intervals containing fixed number elements.","code":""},{"path":"/reference/chop_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into fixed-sized groups — chop_n","text":"","code":"chop_n(x, n, ..., close_end = TRUE, tail = \"split\")  brk_n(n, tail = \"split\")  tab_n(x, n, ..., tail = \"split\")"},{"path":"/reference/chop_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into fixed-sized groups — chop_n","text":"x vector. n Integer. Number elements interval. ... Passed chop(). close_end Logical. Close last break right? (left FALSE, close first break left?) tail String. final interval fewer n elements? \"split\" keep separate. \"merge\" merge neighbouring interval.","code":""},{"path":"/reference/chop_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into fixed-sized groups — chop_n","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into fixed-sized groups — chop_n","text":"algorithm guarantees intervals contain n elements, long duplicates x tail = \"split\". also guarantees intervals contain fewer n elements, except possibly last interval (first interval left FALSE). ensure intervals contain least n elements (long least n elements x!) set tail = \"merge\". tail = \"split\" intervals containing duplicates n elements, warning given.","code":""},{"path":[]},{"path":"/reference/chop_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into fixed-sized groups — chop_n","text":"","code":"chop_n(1:10, 5) #>  [1] [1, 6)  [1, 6)  [1, 6)  [1, 6)  [1, 6)  [6, 10] [6, 10] [6, 10] [6, 10] #> [10] [6, 10] #> Levels: [1, 6) [6, 10]  chop_n(1:5, 2) #> [1] [1, 3) [1, 3) [3, 5) [3, 5) {5}    #> Levels: [1, 3) [3, 5) {5} chop_n(1:5, 2, tail = \"merge\") #> [1] [1, 3) [1, 3) [3, 5] [3, 5] [3, 5] #> Levels: [1, 3) [3, 5]  # too many duplicates x <- rep(1:2, each = 3) chop_n(x, 2) #> Warning: Some intervals contain more than 2 elements #> [1] [1, 2) [1, 2) [1, 2) {2}    {2}    {2}    #> Levels: [1, 2) {2}  tab_n(1:10, 5) #>  [1, 6) [6, 10]  #>       5       5   # fewer elements in one group tab_n(1:10, 4) #>  [1, 5)  [5, 9) [9, 10]  #>       4       4       2"},{"path":"/reference/chop_pretty.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop using pretty breakpoints — chop_pretty","title":"Chop using pretty breakpoints — chop_pretty","text":"chop_pretty() uses base::pretty() calculate breakpoints 1, 2 5 times power 10. look nice graphs.","code":""},{"path":"/reference/chop_pretty.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop using pretty breakpoints — chop_pretty","text":"","code":"chop_pretty(x, n = 5, ...)  brk_pretty(n = 5, ...)  tab_pretty(x, n = 5, ...)"},{"path":"/reference/chop_pretty.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop using pretty breakpoints — chop_pretty","text":"x vector. n Positive integer passed base::pretty(). many intervals chop ? ... Passed chop() chop_pretty() tab_pretty(); passed base::pretty() brk_pretty().","code":""},{"path":"/reference/chop_pretty.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop using pretty breakpoints — chop_pretty","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_pretty.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop using pretty breakpoints — chop_pretty","text":"base::pretty() tries return n+1 breakpoints, .e. n intervals, note guaranteed. methods Date POSIXct objects. fine-grained control base::pretty() parameters, use chop(x, brk_pretty(...)).","code":""},{"path":"/reference/chop_pretty.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop using pretty breakpoints — chop_pretty","text":"","code":"chop_pretty(1:10) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]  chop(1:10, brk_pretty(n = 5, high.u.bias = 0)) #>  [1] [1, 2)  [2, 3)  [3, 4)  [4, 5)  [5, 6)  [6, 7)  [7, 8)  [8, 9)  [9, 10] #> [10] [9, 10] #> Levels: [1, 2) [2, 3) [3, 4) [4, 5) [5, 6) [6, 7) [7, 8) [8, 9) [9, 10]  tab_pretty(1:10) #>  [0, 2)  [2, 4)  [4, 6)  [6, 8) [8, 10]  #>       1       2       2       2       3"},{"path":"/reference/chop_proportions.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into proportions of the range of x — chop_proportions","title":"Chop into proportions of the range of x — chop_proportions","text":"chop_proportions() chops x proportions range, excluding infinite values.","code":""},{"path":"/reference/chop_proportions.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into proportions of the range of x — chop_proportions","text":"","code":"chop_proportions(x, proportions, ..., raw = TRUE)  brk_proportions(proportions)  tab_proportions(x, proportions, ..., raw = TRUE)"},{"path":"/reference/chop_proportions.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into proportions of the range of x — chop_proportions","text":"x vector. proportions Numeric vector 0 1: proportions x's range. proportions names, used labels. ... Passed chop(). raw Logical. Use raw values labels?","code":""},{"path":"/reference/chop_proportions.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into proportions of the range of x — chop_proportions","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_proportions.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into proportions of the range of x — chop_proportions","text":"default, labels show raw numeric endpoints. label intervals proportions, use raw = FALSE.","code":""},{"path":[]},{"path":"/reference/chop_proportions.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into proportions of the range of x — chop_proportions","text":"","code":"chop_proportions(0:10, c(0.2, 0.8)) #>  [1] [0, 2)  [0, 2)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [2, 8)  [8, 10] #> [10] [8, 10] [8, 10] #> Levels: [0, 2) [2, 8) [8, 10] chop_proportions(0:10, c(Low = 0, Mid = 0.2, High = 0.8)) #>  [1] Low  Low  Mid  Mid  Mid  Mid  Mid  Mid  High High High #> Levels: Low Mid High"},{"path":"/reference/chop_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by quantiles — chop_quantiles","title":"Chop by quantiles — chop_quantiles","text":"chop_quantiles() chops data quantiles. chop_deciles() convenience shortcut chops deciles.","code":""},{"path":"/reference/chop_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(x, probs, ..., left = is.numeric(x), raw = FALSE)  chop_deciles(x, ...)  brk_quantiles(probs, ...)  tab_quantiles(x, probs, ..., left = is.numeric(x), raw = FALSE)  tab_deciles(x, ...)"},{"path":"/reference/chop_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by quantiles — chop_quantiles","text":"x vector. probs vector probabilities quantiles. probs names, used labels. ... Passed chop(), brk_quantiles() stats::quantile(). left Logical. Left-closed right-closed breaks? raw Logical. Use raw values labels?","code":""},{"path":"/reference/chop_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by quantiles — chop_quantiles","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop by quantiles — chop_quantiles","text":"non-numeric x, left set FALSE default. works better calculating \"type 1\" quantiles, since round . See stats::quantile().","code":""},{"path":[]},{"path":"/reference/chop_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(1:10, 1:3/4) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%)  #>  [7] [50%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%) [75%, 100%]  chop_quantiles(1:10, c(Q1 = 0, Q2 = 0.25, Q3 = 0.5, Q4 = 0.75)) #>  [1] Q1 Q1 Q1 Q2 Q2 Q3 Q3 Q4 Q4 Q4 #> Levels: Q1 Q2 Q3 Q4  chop(1:10, brk_quantiles(1:3/4)) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%)  #>  [7] [50%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%) [75%, 100%]  chop_deciles(1:10) #>  [1] [0%, 10%)   [10%, 20%)  [20%, 30%)  [30%, 40%)  [40%, 50%)  [50%, 60%)  #>  [7] [60%, 70%)  [70%, 80%)  [80%, 90%)  [90%, 100%] #> 10 Levels: [0%, 10%) [10%, 20%) [20%, 30%) [30%, 40%) [40%, 50%) ... [90%, 100%]  # to label by the quantiles themselves: chop_quantiles(1:10, 1:3/4, raw = TRUE) #>  [1] [1, 3.25)   [1, 3.25)   [1, 3.25)   [3.25, 5.5) [3.25, 5.5) [5.5, 7.75) #>  [7] [5.5, 7.75) [7.75, 10]  [7.75, 10]  [7.75, 10]  #> Levels: [1, 3.25) [3.25, 5.5) [5.5, 7.75) [7.75, 10]  set.seed(42) tab_quantiles(rnorm(100), probs = 1:3/4, raw = TRUE) #> [-2.993, -0.6167) [-0.6167, 0.0898)  [0.0898, 0.6616)   [0.6616, 2.287]  #>                25                25                25                25"},{"path":"/reference/chop_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into fixed-width intervals — chop_width","title":"Chop into fixed-width intervals — chop_width","text":"chop_width() chops x intervals fixed width.","code":""},{"path":"/reference/chop_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into fixed-width intervals — chop_width","text":"","code":"chop_width(x, width, start, ..., left = sign(width) > 0)  brk_width(width, start)  # S3 method for default brk_width(width, start)  tab_width(x, width, start, ..., left = sign(width) > 0)"},{"path":"/reference/chop_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into fixed-width intervals — chop_width","text":"x vector. width Width intervals. start Starting point intervals. default smallest finite x (largest width negative). ... Passed chop(). left Logical. Left-closed right-closed breaks?","code":""},{"path":"/reference/chop_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into fixed-width intervals — chop_width","text":"chop_* functions return factor length x. brk_* functions return function create breaks. tab_* functions return contingency table().","code":""},{"path":"/reference/chop_width.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into fixed-width intervals — chop_width","text":"width negative, chop_width() sets left = FALSE intervals go downwards start.","code":""},{"path":[]},{"path":"/reference/chop_width.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into fixed-width intervals — chop_width","text":"","code":"chop_width(1:10, 2) #>  [1] [1, 3)  [1, 3)  [3, 5)  [3, 5)  [5, 7)  [5, 7)  [7, 9)  [7, 9)  [9, 11] #> [10] [9, 11] #> Levels: [1, 3) [3, 5) [5, 7) [7, 9) [9, 11]  chop_width(1:10, 2, start = 0) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]  chop_width(1:9, -2) #> [1] [1, 3] [1, 3] [1, 3] (3, 5] (3, 5] (5, 7] (5, 7] (7, 9] (7, 9] #> Levels: [1, 3] (3, 5] (5, 7] (7, 9]  chop(1:10, brk_width(2, 0)) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]  tab_width(1:10, 2, start = 0) #>  [0, 2)  [2, 4)  [4, 6)  [6, 8) [8, 10]  #>       1       2       2       2       3"},{"path":"/reference/exactly.html","id":null,"dir":"Reference","previous_headings":"","what":"Define singleton intervals explicitly — exactly","title":"Define singleton intervals explicitly — exactly","text":"exactly() duplicates input. lets define singleton intervals like : chop(x, c(1, exactly(2), 3)). chop(x, c(1, 2, 2, 3)) conveys intent clearly.","code":""},{"path":"/reference/exactly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Define singleton intervals explicitly — exactly","text":"","code":"exactly(x)"},{"path":"/reference/exactly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Define singleton intervals explicitly — exactly","text":"x numeric vector.","code":""},{"path":"/reference/exactly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Define singleton intervals explicitly — exactly","text":"rep(x, = 2).","code":""},{"path":"/reference/exactly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Define singleton intervals explicitly — exactly","text":"","code":"chop(1:10, c(2, exactly(5), 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]  # same: chop(1:10, c(2, 5, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]"},{"path":"/reference/fillet.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop data precisely (for programmers) — fillet","title":"Chop data precisely (for programmers) — fillet","text":"fillet() calls chop() extend = FALSE drop = FALSE. ensures get breaks labels ask . programming, consider using fillet() instead chop().","code":""},{"path":"/reference/fillet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(   x,   breaks,   labels = lbl_intervals(),   left = TRUE,   close_end = TRUE,   raw = NULL )"},{"path":"/reference/fillet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop data precisely (for programmers) — fillet","text":"x vector. breaks numeric vector cut-points function create cut-points x. labels character vector labels function create labels. left Logical. Left-closed right-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) raw Logical. Use raw values labels?","code":""},{"path":"/reference/fillet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop data precisely (for programmers) — fillet","text":"fillet() returns factor length x, representing intervals containing value x.","code":""},{"path":[]},{"path":"/reference/fillet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(1:10, c(2, 5, 8)) #>  [1] <NA>   [2, 5) [2, 5) [2, 5) [5, 8] [5, 8] [5, 8] [5, 8] <NA>   <NA>   #> Levels: [2, 5) [5, 8]"},{"path":"/reference/knife.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated — knife","title":"Deprecated — knife","text":"knife() deprecated favour purrr::partial().","code":""},{"path":"/reference/knife.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated — knife","text":"","code":"knife(...)"},{"path":"/reference/knife.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated — knife","text":"... Parameters chop().","code":""},{"path":"/reference/knife.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated — knife","text":"function.","code":""},{"path":"/reference/lbl_dash.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"label style user-friendly, distinguish left- right-closed intervals. good continuous data expect points exactly breaks.","code":""},{"path":"/reference/lbl_dash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"","code":"lbl_dash(   symbol = em_dash(),   fmt = NULL,   single = \"{l}\",   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_dash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"symbol String: symbol use dash. fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw . Use raw argument chop() instead.","code":""},{"path":"/reference/lbl_dash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_dash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"want unicode output, use lbl_dash(\"-\").","code":""},{"path":"/reference/lbl_dash.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_dash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals like 1-4, 4-5, ... — lbl_dash","text":"","code":"chop(1:10, c(2, 5, 8), lbl_dash()) #>  [1] 1—2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: 1—2 2—5 5—8 8—10  chop(1:10, c(2, 5, 8), lbl_dash(\" to \", fmt = \"%.1f\")) #>  [1] 1.0 to 2.0  2.0 to 5.0  2.0 to 5.0  2.0 to 5.0  5.0 to 8.0  5.0 to 8.0  #>  [7] 5.0 to 8.0  8.0 to 10.0 8.0 to 10.0 8.0 to 10.0 #> Levels: 1.0 to 2.0 2.0 to 5.0 5.0 to 8.0 8.0 to 10.0  chop(1:10, c(2, 5, 8), lbl_dash(first = \"<{r}\")) #>  [1] <2   2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: <2 2—5 5—8 8—10  pretty <- function (x) prettyNum(x, big.mark = \",\", digits = 1) chop(runif(10) * 10000, c(3000, 7000), lbl_dash(\" to \", fmt = pretty)) #>  [1] 7,000 to 9,677 3,000 to 7,000 7,000 to 9,677 3,000 to 7,000 1,579 to 3,000 #>  [6] 3,000 to 7,000 7,000 to 9,677 3,000 to 7,000 1,579 to 3,000 1,579 to 3,000 #> Levels: 1,579 to 3,000 3,000 to 7,000 7,000 to 9,677"},{"path":"/reference/lbl_discrete.html","id":null,"dir":"Reference","previous_headings":"","what":"Label discrete data — lbl_discrete","title":"Label discrete data — lbl_discrete","text":"lbl_discrete() creates labels discrete data, integers. example, breaks c(1, 3, 4, 6, 7) labelled: \"1-2\", \"3\", \"4-5\", \"6-7\".","code":""},{"path":"/reference/lbl_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label discrete data — lbl_discrete","text":"","code":"lbl_discrete(   symbol = em_dash(),   unit = 1,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL )"},{"path":"/reference/lbl_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label discrete data — lbl_discrete","text":"symbol String: symbol use dash. unit Minimum difference distinct values data. integers, 1. fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details.","code":""},{"path":"/reference/lbl_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label discrete data — lbl_discrete","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_discrete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label discrete data — lbl_discrete","text":"check done data discrete-valued. , labels may misleading. , discrete-valued means x < y, x <= y - unit. aware Date objects may non-integer values. See Date.","code":""},{"path":"/reference/lbl_discrete.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label discrete data — lbl_discrete","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label discrete data — lbl_discrete","text":"","code":"tab(1:7, c(1, 3, 5), lbl_discrete()) #> 1—2 3—4 5—7  #>   2   2   3   tab(1:7, c(3, 5), lbl_discrete(first = \"<= {r}\")) #> <= 2  3—4  5—7  #>    2    2    3   tab(1:7 * 1000, c(1, 3, 5) * 1000, lbl_discrete(unit = 1000)) #> 1000—2000 3000—4000 5000—7000  #>         2         2         3   # Misleading labels for non-integer data chop(2.5, c(1, 3, 5), lbl_discrete()) #> [1] 1—2 #> Levels: 1—2"},{"path":"/reference/lbl_endpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their left or right endpoints — lbl_endpoint","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"useful left endpoint unambiguously indicates interval. cases may give errors due duplicate labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)"},{"path":"/reference/lbl_endpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"fmt String function. format break endpoints. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? left Flag. Use left endpoint right endpoint?","code":""},{"path":"/reference/lbl_endpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"fmt NULL used format endpoints. fmt string numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"chop(1:10, c(2, 5, 8), lbl_endpoint(left = TRUE)) #>  [1] 1 2 2 2 5 5 5 8 8 8 #> Levels: 1 2 5 8 chop(1:10, c(2, 5, 8), lbl_endpoint(left = FALSE)) #>  [1] 2  5  5  5  8  8  8  10 10 10 #> Levels: 2 5 8 10 if (requireNamespace(\"lubridate\")) {   tab_width(           as.Date(\"2000-01-01\") + 0:365,          months(1),          labels = lbl_endpoint(fmt = \"%b\")        ) } #> Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec  #>  31  29  31  30  31  30  31  31  30  31  30  31"},{"path":"/reference/lbl_endpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their left or right endpoints — lbl_endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"useful left endpoint unambiguously indicates interval. cases may give errors due duplicate labels.","code":""},{"path":"/reference/lbl_endpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"","code":"lbl_endpoints(   left = TRUE,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE )  lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)"},{"path":"/reference/lbl_endpoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"left Flag. Use left endpoint right endpoint? fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw . Use raw argument chop() instead.","code":""},{"path":"/reference/lbl_endpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_endpoints.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"lbl_endpoint() . use .","code":""},{"path":"/reference/lbl_endpoints.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_endpoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their left or right endpoints — lbl_endpoints","text":"","code":"chop(1:10, c(2, 5, 8), lbl_endpoints(left = TRUE)) #>  [1] 1 2 2 2 5 5 5 8 8 8 #> Levels: 1 2 5 8 chop(1:10, c(2, 5, 8), lbl_endpoints(left = FALSE)) #>  [1] 2  5  5  5  8  8  8  10 10 10 #> Levels: 2 5 8 10 if (requireNamespace(\"lubridate\")) {   tab_width(           as.Date(\"2000-01-01\") + 0:365,          months(1),          labels = lbl_endpoints(fmt = \"%b\")        ) } #> Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec  #>  31  29  31  30  31  30  31  31  30  31  30  31   if (FALSE) {   # This gives breaks `[1, 2) [2, 3) {3}` which lead to   # duplicate labels `\"2\", \"3\", \"3\"`:   chop(1:3, 1:3, lbl_endpoints(left = FALSE)) }"},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"lbl_format(fmt, fmt1 = \"%.3g\", raw = FALSE)"},{"path":"/reference/lbl_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. fmt1 Format breaks consisting single value. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_format.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"labels let format breaks arbitrarily, using either string (passed sprintf()) function. fmt function, must accept two arguments, representing left right endpoints interval. breaks non-numeric, can use \"%s\" string fmt. breaks converted character case. lbl_format() \"questioning\" stage. alternative, consider using lbl_dash() lbl_intervals() fmt argument.","code":""},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\")) #>  1 to 3       3  3 to 7 7 to 10  #>       2       1       3       4  tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\", \"Exactly %.3g\")) #>    1 to 3 Exactly 3    3 to 7   7 to 10  #>         2         1         3         4   percent2 <- function (x, y) {   sprintf(\"%.2f%% - %.2f%%\", x*100, y*100) } tab(runif(100), c(0.25, 0.5, .75),       labels = lbl_format(percent2)) #>  0.64% - 25.00% 25.00% - 50.00% 50.00% - 75.00% 75.00% - 98.41%  #>              21              20              33              26"},{"path":"/reference/lbl_glue.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals using the glue package — lbl_glue","title":"Label chopped intervals using the glue package — lbl_glue","text":"Use \"{l}\" \"{r}\" show left right endpoints intervals.","code":""},{"path":"/reference/lbl_glue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals using the glue package — lbl_glue","text":"","code":"lbl_glue(   label,   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE,   ... )"},{"path":"/reference/lbl_glue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals using the glue package — lbl_glue","text":"label glue string passed glue::glue(). fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw . Use raw argument chop() instead. ... arguments passed glue::glue().","code":""},{"path":"/reference/lbl_glue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals using the glue package — lbl_glue","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_glue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals using the glue package — lbl_glue","text":"following variables available glue string: l character vector left endpoints intervals. r character vector right endpoints intervals. l_closed logical vector. Elements TRUE left endpoint closed. r_closed logical vector, TRUE right endpoint closed. Endpoints formatted fmt passed glue().","code":""},{"path":"/reference/lbl_glue.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals using the glue package — lbl_glue","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_glue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals using the glue package — lbl_glue","text":"","code":"tab(1:10, c(1, 3, 3, 7),     labels = lbl_glue(\"{l} to {r}\", single = \"Exactly {l}\")) #>    1 to 3 Exactly 3    3 to 7   7 to 10  #>         2         1         3         4   tab(1:10 * 1000, c(1, 3, 5, 7) * 1000,     labels = lbl_glue(\"{l}-{r}\",                       fmt = function(x) prettyNum(x, big.mark=','))) #>  1,000-3,000  3,000-5,000  5,000-7,000 7,000-10,000  #>            2            2            2            4   # reproducing lbl_intervals(): interval_left <- \"{ifelse(l_closed, '[', '(')}\" interval_right <- \"{ifelse(r_closed, ']', ')')}\" glue_string <- paste0(interval_left, \"{l}\", \", \", \"{r}\", interval_right) tab(1:10, c(1, 3, 3, 7), labels = lbl_glue(glue_string, single = \"{{{l}}}\")) #>  [1, 3)     {3}  (3, 7) [7, 10]  #>       2       1       3       4"},{"path":"/reference/lbl_intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals using set notation — lbl_intervals","title":"Label chopped intervals using set notation — lbl_intervals","text":"labels exact, since show whether intervals \"closed\" \"open\", .e. whether include endpoints.","code":""},{"path":"/reference/lbl_intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"lbl_intervals(   fmt = NULL,   single = \"{{{l}}}\",   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals using set notation — lbl_intervals","text":"fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw . Use raw argument chop() instead.","code":""},{"path":"/reference/lbl_intervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals using set notation — lbl_intervals","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_intervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals using set notation — lbl_intervals","text":"Mathematical set notation looks like : [, b]: numbers x <= x <= b; (, b): numbers < x < b; [, b): numbers <= x < b; (, b]: numbers < x <= b; {}: just number exactly.","code":""},{"path":"/reference/lbl_intervals.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals using set notation — lbl_intervals","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_intervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"tab(-10:10, c(-3, 0, 0, 3),       labels = lbl_intervals()) #> [-10, -3)   [-3, 0)       {0}    (0, 3)   [3, 10]  #>         7         3         1         2         8   tab(-10:10, c(-3, 0, 0, 3),       labels = lbl_intervals(fmt = list(nsmall = 1))) #> [-10.0,  -3.0) [ -3.0,   0.0)        {  0.0} (  0.0,   3.0) [  3.0,  10.0]  #>              7              3              1              2              8   tab_evenly(runif(20), 10,       labels = lbl_intervals(fmt = percent)) #> [4.835%, 13.97%)  [13.97%, 23.1%)  [23.1%, 32.23%) [32.23%, 41.36%)  #>                2                2                3                2  #> [41.36%, 50.49%) [50.49%, 59.62%) [59.62%, 68.75%) [77.88%, 87.02%)  #>                2                4                1                2  #> [87.02%, 96.15%]  #>                2"},{"path":[]},{"path":"/reference/lbl_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"lbl_manual(sequence, fmt = \"%s\")"},{"path":"/reference/lbl_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"sequence character vector labels. fmt String, list function. format break endpoints.","code":""},{"path":"/reference/lbl_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_manual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"lbl_manual() deprecated little used closely related rest package. also risks mislabelling intervals, e.g. intervals extended. lbl_manual() uses arbitrary sequence label intervals. sequence short, pasted repeated.","code":""},{"path":"/reference/lbl_manual.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"chop(1:10, c(2, 5, 8), lbl_manual(c(\"w\", \"x\", \"y\", \"z\"))) #> Warning: `lbl_manual()` was deprecated in santoku 0.9.0. #> ℹ Just specify `labels = sequence` instead. #>  [1] w x x x y y y z z z #> Levels: w x y z # -> chop(1:10, c(2, 5, 8), labels = c(\"w\", \"x\", \"y\", \"z\")) #>  [1] w x x x y y y z z z #> Levels: w x y z"},{"path":"/reference/lbl_midpoints.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their midpoints — lbl_midpoints","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"uses midpoint interval label.","code":""},{"path":"/reference/lbl_midpoints.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"","code":"lbl_midpoints(   fmt = NULL,   single = NULL,   first = NULL,   last = NULL,   raw = FALSE )"},{"path":"/reference/lbl_midpoints.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"fmt String, list function. format break endpoints. single Glue string: label singleton intervals. See lbl_glue() details. first Glue string: override label first category. Write e.g. first = \"<{r}\" create label like \"<18\". See lbl_glue() details. last String: override label last category. Write e.g. last = \">{l}\" create label like \">65\". See lbl_glue() details. raw . Use raw argument chop() instead.","code":""},{"path":"/reference/lbl_midpoints.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_midpoints.html","id":"formatting-endpoints","dir":"Reference","previous_headings":"","what":"Formatting endpoints","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"fmt NULL used format endpoints. fmt string, numeric endpoints formatted sprintf(fmt, breaks); endpoints, e.g. Date objects, formatted format(breaks, fmt). fmt list, used arguments format. fmt function, take vector numbers (objects can used breaks) return character vector. may helpful use functions {scales} package, e.g. scales::label_comma().","code":""},{"path":[]},{"path":"/reference/lbl_midpoints.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their midpoints — lbl_midpoints","text":"","code":"chop(1:10, c(2, 5, 8), lbl_midpoints()) #>  [1] 1.5 3.5 3.5 3.5 6.5 6.5 6.5 9   9   9   #> Levels: 1.5 3.5 6.5 9"},{"path":"/reference/lbl_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals in sequence — lbl_seq","title":"Label chopped intervals in sequence — lbl_seq","text":"lbl_seq() labels intervals sequentially, using numbers letters.","code":""},{"path":"/reference/lbl_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"lbl_seq(start = \"a\")"},{"path":"/reference/lbl_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in sequence — lbl_seq","text":"start String. template sequence. See .","code":""},{"path":"/reference/lbl_seq.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals in sequence — lbl_seq","text":"function creates vector labels.","code":""},{"path":"/reference/lbl_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals in sequence — lbl_seq","text":"start shows first element sequence. must contain exactly one character set \"\", \"\", \"\", \"\" \"1\". later elements: \"\" replaced \"\", \"b\", \"c\", ... \"\" replaced \"\", \"B\", \"C\", ... \"\" replaced lower-case Roman numerals \"\", \"ii\", \"iii\", ... \"\" replaced upper-case Roman numerals \"\", \"II\", \"III\", ... \"1\" replaced numbers \"1\", \"2\", \"3\", ... characters retained -.","code":""},{"path":[]},{"path":"/reference/lbl_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"chop(1:10, c(2, 5, 8), lbl_seq()) #>  [1] a b b b c c c d d d #> Levels: a b c d  chop(1:10, c(2, 5, 8), lbl_seq(\"i.\")) #>  [1] i.   ii.  ii.  ii.  iii. iii. iii. iv.  iv.  iv.  #> Levels: i. ii. iii. iv.  chop(1:10, c(2, 5, 8), lbl_seq(\"(A)\")) #>  [1] (A) (B) (B) (B) (C) (C) (C) (D) (D) (D) #> Levels: (A) (B) (C) (D)"},{"path":"/reference/non-standard-types.html","id":null,"dir":"Reference","previous_headings":"","what":"Tips for chopping non-standard types — non-standard-types","title":"Tips for chopping non-standard types — non-standard-types","text":"Santoku can handle many non-standard types.","code":""},{"path":"/reference/non-standard-types.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Tips for chopping non-standard types — non-standard-types","text":"objects can compared using <, == etc. choppable. Objects converted numeric handled within R code, may slower. Character x breaks chopped warning. x breaks type, able cast type, usually using vctrs::vec_cast_common(). chopping operations make sense, example, chop_mean_sd() character vector. indexed objects stats::ts() objects, indices dropped result. get errors, try setting extend = FALSE (also file bug report). request support type, open issue Github.","code":""},{"path":[]},{"path":"/reference/percent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple percentage formatter — percent","title":"Simple percentage formatter — percent","text":"percent() formats x percentage. wider range formatters, consider scales package.","code":""},{"path":"/reference/percent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple percentage formatter — percent","text":"","code":"percent(x)"},{"path":"/reference/percent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple percentage formatter — percent","text":"x Numeric values.","code":""},{"path":"/reference/percent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple percentage formatter — percent","text":"x formatted percent.","code":""},{"path":"/reference/percent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple percentage formatter — percent","text":"","code":"percent(0.5) #> [1] \"50%\""},{"path":"/reference/santoku-cast.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal functions — santoku-cast","title":"Internal functions — santoku-cast","text":"Internal functions","code":""},{"path":"/reference/santoku-cast.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal functions — santoku-cast","text":"","code":"# S3 method for default santoku_cast_common(x, y)  # S3 method for double santoku_cast_common(x, y)  # S3 method for Date santoku_cast_common(x, y)  # S3 method for POSIXct santoku_cast_common(x, y)  # S3 method for ts santoku_cast_common(x, y)  # S3 method for zoo santoku_cast_common(x, y)  # S3 method for integer64 santoku_cast_common(x, y)  # S3 method for hexmode santoku_cast_common(x, y)  # S3 method for octmode santoku_cast_common(x, y)"},{"path":"/reference/santoku-cast.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Internal functions — santoku-cast","text":"x, y Vectors cast.","code":""},{"path":"/reference/santoku-cast.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Internal functions — santoku-cast","text":"list.","code":""},{"path":"/reference/santoku-package.html","id":null,"dir":"Reference","previous_headings":"","what":"A versatile cutting tool for R — santoku-package","title":"A versatile cutting tool for R — santoku-package","text":"santoku tool cutting data intervals. provides function chop(), similar base R's cut() Hmisc::cut2(). chop(x, breaks) takes vector x returns factor length, coding interval element x falls .","code":""},{"path":"/reference/santoku-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A versatile cutting tool for R — santoku-package","text":"advantages santoku: default, chop() always covers whole range data, get unexpected NA values. Unlike cut() cut2(), chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. Flexible easy labelling. Convenience functions creating quantile intervals, evenly-spaced intervals equal-sized groups. Convenience functions quickly tabulate chopped data. Can chop numbers, dates, date-times objects. advantages make santoku especially useful exploratory analysis, may know range data advance. get started, read vignette:   details, start documentation chop().","code":"vignette(\"santoku\")"},{"path":[]},{"path":"/reference/santoku-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A versatile cutting tool for R — santoku-package","text":"Maintainer: David Hugh-Jones davidhughjones@gmail.com contributors: Daniel Possenriede possenriede@gmail.com [contributor]","code":""},{"path":"/reference/tab.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate data by intervals — tab","title":"Tabulate data by intervals — tab","text":"functions call related chop_xxx function, call table() result.","code":""},{"path":"/reference/tab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate data by intervals — tab","text":"","code":"tab(...)  tab_width(...)  tab_evenly(...)  tab_n(...)  tab_mean_sd(...)  tab_quantiles(...)  tab_deciles(...)  tab_equally(...)"},{"path":"/reference/tab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate data by intervals — tab","text":"... Passed chop","code":""},{"path":"/reference/tab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tabulate data by intervals — tab","text":"table().","code":""},{"path":"/reference/tab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate data by intervals — tab","text":"","code":"tab(1:10, c(2, 5, 8)) #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3   tab_mean_sd(1:10) #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              2              3              3              2   tab_equally(rpois(50, 4), groups = 4) #>   [0%, 25%)  [25%, 50%)  [50%, 75%) [75%, 100%]  #>          10          12           8          20"},{"path":"/news/index.html","id":"santoku-0100","dir":"Changelog","previous_headings":"","what":"santoku 0.10.0","title":"santoku 0.10.0","text":"CRAN release: 2023-10-12 List arguments fmt lbl_* functions taken arguments base::format. gives flexibility formatting, e.g., units breaks. chop_n() gains tail argument, deal last interval containing less n elements. Set tail = \"merge\" merge previous interval. guarantees intervals contain least n elements. chop_equally() may return fewer groups groups duplicate elements. now warn happens. Bugfix: chop_n() return intervals fewer n elements duplicate elements. new algorithm avoids , may slower case.","code":""},{"path":"/news/index.html","id":"santoku-091","dir":"Changelog","previous_headings":"","what":"santoku 0.9.1","title":"santoku 0.9.1","text":"CRAN release: 2023-03-08 endpoint_labels() methods gain unused ... argument satisfy R CMD CHECK.","code":""},{"path":"/news/index.html","id":"santoku-090","dir":"Changelog","previous_headings":"","what":"santoku 0.9.0","title":"santoku 0.9.0","text":"CRAN release: 2022-11-01","code":""},{"path":"/news/index.html","id":"breaking-changes-0-9-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"santoku 0.9.0","text":"important changes close_end. close_end now TRUE default chop() fillet(). previous versions: Whereas now: close_end now always applied extend. example, previous versions: Whereas now: changed behaviour line user expectations. breaks names, used labels: Names can also used labels probs chop_quantiles() proportions chop_proportions(). new raw parameter chop(). replaces parameter raw lbl_* functions, now soft-deprecated. lbl_manual() deprecated. Just use vector argument labels instead. labels argument chop_quantiles() now needs explicitly named. expect last important breaking changes release version 1.0 mark package “stable”. cause problems , please file issue.","code":"chop(1:2, 1:2) ## [1] [1, 2) {2}    ## Levels: [1, 2) {2} chop(1:2, 1:2) ## [1] [1, 2] [1, 2] ## Levels: [1, 2] chop(1:4, 2:3, close_end = TRUE) ## [1] [1, 2) [2, 3] [2, 3] (3, 4] ## Levels: [1, 2) [2, 3] (3, 4] chop(1:4, 2:3, close_end = TRUE) ## [1] [1, 2) [2, 3) [3, 4] [3, 4] ## Levels: [1, 2) [2, 3) [3, 4] chop(1:5, c(Low = 1, Mid = 2, High = 4)) ## [1] Low  Mid  Mid  High High ## Levels: Low Mid High"},{"path":"/news/index.html","id":"other-changes-0-9-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.9.0","text":"New chop_fn(), brk_fn() tab_fn() chop using arbitrary function. Added section non-standard objects vignette.","code":""},{"path":"/news/index.html","id":"santoku-080","dir":"Changelog","previous_headings":"","what":"santoku 0.8.0","title":"santoku 0.8.0","text":"CRAN release: 2022-06-08","code":""},{"path":"/news/index.html","id":"breaking-changes-0-8-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"santoku 0.8.0","text":"lbl_endpoint() renamed lbl_endpoints(). old version trigger deprecation warning. lbl_endpoints() gains first, last single arguments like labelling functions.","code":""},{"path":"/news/index.html","id":"other-changes-0-8-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.8.0","text":"New chop_pretty(), brk_pretty() tab_pretty() functions use base::pretty() calculate attractive breakpoints. Thanks @davidhodge931. New chop_proportions(), brk_proportions() tab_proportions() functions chop x proportions range. chop_equally() now uses lbl_intervals(raw = TRUE) default, bringing line chop_evenly(), chop_width() chop_n(). New lbl_midpoints() function labels breaks midpoints. lbl_discrete() gains single argument. can now chop ts, xts::xts zoo::zoo objects. Date objects POSIXct breaks, vice versa bit64::integer64 doubles Bugfix: lbl_discrete() sometimes ugly label formatting.","code":""},{"path":"/news/index.html","id":"santoku-070","dir":"Changelog","previous_headings":"","what":"santoku 0.7.0","title":"santoku 0.7.0","text":"CRAN release: 2022-03-18","code":""},{"path":"/news/index.html","id":"breaking-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Breaking changes","title":"santoku 0.7.0","text":"labelling functions, first last arguments now passed glue::glue(). Variables l r represent left right endpoints intervals. chop_mean_sd() now takes vector sds standard deviations, rather single maximum number sd standard deviations. Write e.g.  chop_mean_sd(sds = 1:3) rather chop_mean_sd(sd = 3). sd argument deprecated. groups argument chop_evenly(), deprecated 0.4.0, removed. brk_left() brk_right(), deprecated 0.4.0, removed. knife(), deprecated 0.4.0, removed. lbl_format(), questioning since 0.4.0, removed. Arguments lbl_dash() lbl_intervals() reordered consistency labelling functions.","code":""},{"path":"/news/index.html","id":"other-changes-0-7-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.7.0","text":"Character vectors chopped lexicographic order, optional warning. problems chopping vector type, file bug report. glue package become hard dependency. used many places format labels. new lbl_glue() function using glue package. Thanks @dpprdan. can now set labels = NULL return integer codes. Arguments first, last single can used lbl_intervals() lbl_dash(), override first last interval labels, label singleton intervals. lbl_dash() lbl_discrete() use unicode em-dash possible. brk_default() throws error breaks sorted.","code":""},{"path":"/news/index.html","id":"bugfixes-0-7-0","dir":"Changelog","previous_headings":"","what":"Bugfixes","title":"santoku 0.7.0","text":"Bugfix: tab() friends longer display x variable name. Bugfix: lbl_endpoint() erroring types breaks.","code":""},{"path":"/news/index.html","id":"santoku-060","dir":"Changelog","previous_headings":"","what":"santoku 0.6.0","title":"santoku 0.6.0","text":"CRAN release: 2021-11-04 New arguments first last lbl_dash() lbl_discrete() allow override first last interval labels. Fixes CRAN.","code":""},{"path":"/news/index.html","id":"santoku-050","dir":"Changelog","previous_headings":"","what":"santoku 0.5.0","title":"santoku 0.5.0","text":"CRAN release: 2020-08-27 sets left = FALSE default. Also works negative time intervals.","code":""},{"path":"/news/index.html","id":"santoku-041","dir":"Changelog","previous_headings":"","what":"santoku 0.4.1","title":"santoku 0.4.1","text":"CRAN release: 2020-06-16 Bugfix: chop(1:4, 1) erroring.","code":""},{"path":"/news/index.html","id":"santoku-040","dir":"Changelog","previous_headings":"","what":"santoku 0.4.0","title":"santoku 0.4.0","text":"CRAN release: 2020-06-09","code":""},{"path":"/news/index.html","id":"interface-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Interface changes","title":"santoku 0.4.0","text":"new version interface changes. based user experience, designed make using chop() intuitive predictable. chop() two new arguments, left close_end. Using left = FALSE simpler intuitive wrapping breaks brk_right(). brk_left() brk_right() kept now, used wrap break functions. Using close_end simpler passing close_end brk_left() brk_right() (longer accept argument directly). left = TRUE default, except non-numeric objects chop_quantiles() chop_equally(), left = FALSE works better. close_end now FALSE default. prevents user surprises e.g. chop(3, 1:3) puts 3 different category chop(3, 1:4). close_end TRUE default chop_quantiles(), chop_n() similar functions. ensures e.g.  chop_quantiles(x, c(0, 1/3, 2/3, 1)) expect. groups argument chop_evenly() renamed groups intervals. make easier remember difference chop_evenly() chop_equally(). (Chop evenly n equal-width intervals, chop equally n equal-sized groups.) knife() deprecated keep interface slim focused. Use purrr::partial() instead.","code":""},{"path":"/news/index.html","id":"other-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.4.0","text":"Date datetime (POSIXct) objects can now chopped. chop_width() accepts difftime, lubridate::period lubridate::duration objects chop_ functions work well. Many labelling functions new fmt argument. can string interpreted sprintf() format(), 1-argument formatting function break endpoints, e.g. scales::label_percent(). Experimental: lbl_discrete() discrete data integers () dates. new lbl_endpoint() function labelling intervals solely left right endpoint. brk_mean_sd() now accepts non-integer positive numbers. Add brk_equally() symmetry chop_equally(). Minor tweaks chop_deciles(). Bugfix: lbl_format() wasn’t accepting numeric formats, even raw = TRUE. Thanks Sharla Gelfand.","code":""},{"path":"/news/index.html","id":"santoku-030","dir":"Changelog","previous_headings":"","what":"santoku 0.3.0","title":"santoku 0.3.0","text":"CRAN release: 2020-01-24 First CRAN release. Changed kut() kiru(). kiru() alternative spelling chop(), use tidyr package loaded. lbl_sequence() become lbl_manual(). lbl_letters() friends replaced lbl_seq(): replace lbl_letters() use lbl_seq() replace lbl_LETTERS() use lbl_seq(\"\") replace lbl_roman() use lbl_seq(\"\") replace lbl_ROMAN() use lbl_seq(\"\") replace lbl_numerals() use lbl_seq(\"1\") complex formatting use e.g. lbl_seq(\":\"), lbl_seq(\"()\")","code":""},{"path":"/news/index.html","id":"santoku-020","dir":"Changelog","previous_headings":"","what":"santoku 0.2.0","title":"santoku 0.2.0","text":"Added NEWS.md file track changes package. Default labels extend = NULL changed, [-Inf, ... ..., Inf] [min(x), ... ..., max(x)].","code":""}]
