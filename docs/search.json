[{"path":"/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2019 David Hugh-Jones Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"/TODO.html","id":null,"dir":"","previous_headings":"","what":"TODO","title":"TODO","text":"tests left close_end arguments tests brk_default brk_width() needs tests match guarantees documentation ditto brk_evenly() now uses implementation guarantee exactly intervals intervals systematic tests brk_* functions tab_quantiles needs raw labels default, useful note effectively gonna chop_width(x, width, start) . might want something like: chop(dates, dates + weeks(1:3)) already work able chop Intervals? isn’t chop_width isn’t fixed--time Interval; non-overlapping sequence intervals chop . equally just chop start times. ts, xts, zoo, package_version, units? brk_days(), brk_weeks() etc.? Equivalent lubridate’s days() etc. classes? Implement simple Infinity class automatically casts class always > < element? replace class_bounds() complexity?","code":""},{"path":"/TODO.html","id":"thoughts-on-errors","dir":"","previous_headings":"","what":"Thoughts on errors","title":"TODO","text":"Exception: x wrong class type. e.g. brk_manual() extend set. cases, e.g. brk_evenly() don’t need make guarantee.","code":""},{"path":"/TODO.html","id":"questions","dir":"","previous_headings":"","what":"Questions","title":"TODO","text":"alternative x non-numeric. makes surprise rarer, rare surprises can worse… adds complexity since functions generic. another alternative: chop sets left = FALSE non-numeric x. Probably better. drop default ! isTRUE(extend) .e. FALSE extend = TRUE? ’m skeptical, forcats() exists suggesting factors aren’t yet seen worthless! Maybe output = c(\"factor\", \"character\", \"numeric\") switch , drop probably work even numeric .e. integer data moving start 1","code":""},{"path":"/TODO.html","id":"questions-with-a-provisional-answer","dir":"","previous_headings":"","what":"Questions with a (provisional) answer","title":"TODO","text":"sense , unless someone asks. Oh, someone just ask; generally though. . don’t want people set position, distinguish initial arguments. Current answer: fuck ’em. (NB: just kidding. huge tidyverse fan.) provide kiru(). REPL, people can just use kiru() load santoku first. load santoku second, ’ll use tidyr::chop(), reading documentation, suspect rare. programming, people probably used fully qualified name anyway. think default “necessary” (extend = NULL); always extend Inf, -Inf break labels data-dependent Tension wanting something predictable new data, vs. something readable tab_*. E.g. surely return labels , b, c. means aren’t always extending. lets people e.g. chop(rnorm(100), -2:2, LETTERS) might hide errors overall ’m maybe label functions access x? informed breaks got extended? breaks object know extend labels? current solution: labels get extend think better: breaks objects include suggested labels user can override. way always info necessary. choosing break numbers (may actual values, e.g quantiles std errs 0) formatting numbers, dashes, set notation etc maybe brk_* functions always return break numbers; labels decide format ? warning? currently error throw error cases e.g. brk_quantiles, brk_width, data may work well e.g. NA. empty set breaks?","code":"tab_size(1:9, 3, lbl_seq())"},{"path":"/TODO.html","id":"possible-interfaces","dir":"","previous_headings":"","what":"Possible interfaces","title":"TODO","text":"hist_xxx functions histograms/barplots? (treat singletons?) grp_xxx group_by? Hmmm… New label interface replace lbl_sequence: lbl_style(\"1.\"), lbl_style(\"()\"), lbl_style(\"\") etc.? Still wonder, drop extend adds complexity just () extend() new breaks functions?","code":""},{"path":"/TODO.html","id":"other-ideas","dir":"","previous_headings":"","what":"Other ideas","title":"TODO","text":"Speedup categorize checking left intervals, add 1 past interval [: actually fewer checks end…] Speedup using pointers? hmm, magic…","code":""},{"path":"/articles/santoku.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"Introduction to santoku","text":"install santoku, run:","code":"install.packages(\"santoku\")"},{"path":"/articles/santoku.html","id":"basic-usage","dir":"Articles","previous_headings":"","what":"Basic usage","title":"Introduction to santoku","text":"Use chop() like cut() cut data : chop() returns factor. data beyond limits breaks, extended automatically: chop single number separate category, put number twice breaks: quickly produce table chopped data, use tab():","code":"library(santoku) x <- runif(10, 0, 10) (chopped <- chop(x, breaks = 0:10)) #>  [1] [4, 5)  [8, 9)  [3, 4)  [4, 5)  [7, 8)  [9, 10) [6, 7)  [8, 9)  [1, 2)  #> [10] [4, 5)  #> Levels: [1, 2) [3, 4) [4, 5) [6, 7) [7, 8) [8, 9) [9, 10) data.frame(x, chopped) #>           x chopped #> 1  4.978305  [4, 5) #> 2  8.969989  [8, 9) #> 3  3.391823  [3, 4) #> 4  4.676785  [4, 5) #> 5  7.057042  [7, 8) #> 6  9.707687 [9, 10) #> 7  6.713807  [6, 7) #> 8  8.376589  [8, 9) #> 9  1.086165  [1, 2) #> 10 4.495479  [4, 5) chopped <- chop(x, breaks = 3:7) data.frame(x, chopped) #>           x    chopped #> 1  4.978305     [4, 5) #> 2  8.969989 [7, 9.708] #> 3  3.391823     [3, 4) #> 4  4.676785     [4, 5) #> 5  7.057042 [7, 9.708] #> 6  9.707687 [7, 9.708] #> 7  6.713807     [6, 7) #> 8  8.376589 [7, 9.708] #> 9  1.086165 [1.086, 3) #> 10 4.495479     [4, 5) x_fives <- x x_fives[1:5] <- 5 chopped <- chop(x_fives, c(2, 5, 5, 8)) data.frame(x_fives, chopped) #>     x_fives    chopped #> 1  5.000000        {5} #> 2  5.000000        {5} #> 3  5.000000        {5} #> 4  5.000000        {5} #> 5  5.000000        {5} #> 6  9.707687 [8, 9.708] #> 7  6.713807     (5, 8) #> 8  8.376589 [8, 9.708] #> 9  1.086165 [1.086, 2) #> 10 4.495479     [2, 5) tab(1:10, c(2, 5, 8)) #> x #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3"},{"path":"/articles/santoku.html","id":"more-ways-to-chop","dir":"Articles","previous_headings":"","what":"More ways to chop","title":"Introduction to santoku","text":"chop fixed-width intervals, starting minimum value, use chop_width(): chop exactly intervals fixed-intervals, use chop_evenly(): chop groups fixed number members, use chop_n(): chop fixed number equal-sized groups, use chop_equally(): chop data quantiles, use chop_quantiles(): chop data standard deviations around mean, use chop_mean_sd(): tab_n(), tab_width(), tab_evenly() tab_mean_sd() act similarly tab(), calling related chop_ function table(). can chop dates :","code":"chopped <- chop_width(x, 2) data.frame(x, chopped) #>           x        chopped #> 1  4.978305 [3.086, 5.086) #> 2  8.969989 [7.086, 9.086) #> 3  3.391823 [3.086, 5.086) #> 4  4.676785 [3.086, 5.086) #> 5  7.057042 [5.086, 7.086) #> 6  9.707687 [9.086, 11.09) #> 7  6.713807 [5.086, 7.086) #> 8  8.376589 [7.086, 9.086) #> 9  1.086165 [1.086, 3.086) #> 10 4.495479 [3.086, 5.086) chopped <- chop_evenly(x, intervals = 3) data.frame(x, chopped) #>           x        chopped #> 1  4.978305  [3.96, 6.834) #> 2  8.969989 [6.834, 9.708] #> 3  3.391823  [1.086, 3.96) #> 4  4.676785  [3.96, 6.834) #> 5  7.057042 [6.834, 9.708] #> 6  9.707687 [6.834, 9.708] #> 7  6.713807  [3.96, 6.834) #> 8  8.376589 [6.834, 9.708] #> 9  1.086165  [1.086, 3.96) #> 10 4.495479  [3.96, 6.834) chopped <- chop_n(x, 4) table(chopped) #> chopped #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 chopped <- chop_equally(x, groups = 5) table(chopped) #> chopped #>   [0%, 20%)  [20%, 40%)  [40%, 60%)  [60%, 80%) [80%, 100%]  #>           2           2           2           2           2 chopped <- chop_quantiles(x, c(0.25, 0.5, 0.75)) data.frame(x, chopped) #>           x     chopped #> 1  4.978305  [25%, 50%) #> 2  8.969989 (75%, 100%] #> 3  3.391823   [0%, 25%) #> 4  4.676785  [25%, 50%) #> 5  7.057042  [50%, 75%] #> 6  9.707687 (75%, 100%] #> 7  6.713807  [50%, 75%] #> 8  8.376589 (75%, 100%] #> 9  1.086165   [0%, 25%) #> 10 4.495479   [0%, 25%) chopped <- chop_mean_sd(x) data.frame(x, chopped) #>           x        chopped #> 1  4.978305  [-1 sd, 0 sd) #> 2  8.969989   [1 sd, 2 sd) #> 3  3.391823  [-1 sd, 0 sd) #> 4  4.676785  [-1 sd, 0 sd) #> 5  7.057042   [0 sd, 1 sd) #> 6  9.707687   [1 sd, 2 sd) #> 7  6.713807   [0 sd, 1 sd) #> 8  8.376589   [0 sd, 1 sd) #> 9  1.086165 [-2 sd, -1 sd) #> 10 4.495479  [-1 sd, 0 sd) tab_n(x, 4) #> x #> [1.086, 4.978)  [4.978, 8.97)  [8.97, 9.708]  #>              4              4              2 tab_width(x, 2) #> x #> [1.086, 3.086) [3.086, 5.086) [5.086, 7.086) [7.086, 9.086) [9.086, 11.09)  #>              1              4              2              2              1 tab_evenly(x, 5) #> x #>  [1.086, 2.81)  [2.81, 4.535) [4.535, 6.259) [6.259, 7.983) [7.983, 9.708]  #>              1              2              2              2              3 tab_mean_sd(x) #> x #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              1              4              3              2 library(lubridate) #>  #> Attaching package: 'lubridate' #> The following objects are masked from 'package:base': #>  #>     date, intersect, setdiff, union y2k <- as.Date(\"2000-01-01\") + 0:365 months <- chop_width(y2k, months(1)) table(months) #> months #> [2000-01-01, 2000-02-01) [2000-02-01, 2000-03-01) [2000-03-01, 2000-04-01)  #>                       31                       29                       31  #> [2000-04-01, 2000-05-01) [2000-05-01, 2000-06-01) [2000-06-01, 2000-07-01)  #>                       30                       31                       30  #> [2000-07-01, 2000-08-01) [2000-08-01, 2000-09-01) [2000-09-01, 2000-10-01)  #>                       31                       31                       30  #> [2000-10-01, 2000-11-01) [2000-11-01, 2000-12-01) [2000-12-01, 2001-01-01)  #>                       31                       30                       31"},{"path":"/articles/santoku.html","id":"advanced-usage","dir":"Articles","previous_headings":"","what":"Advanced usage","title":"Introduction to santoku","text":"can change factor labels labels argument: need many labels intervals - one fewer length(breaks) data doesn’t extend beyond breaks, one length(breaks) . label intervals dash, use lbl_dash(): can customize first last labels: label intervals order use lbl_seq(): can use numerals even roman numerals: labelling functions include: lbl_discrete(), integer data lbl_endpoint(), use left endpoints labels lbl_manual(), specify labels manually default, chop() extends breaks necessary. don’t want , set extend = FALSE: Data outside range breaks become NA. default, intervals closed left, .e. include left endpoints. want right-closed intervals, set left = FALSE: want close last interval, set close_end = TRUE:","code":"chopped <- chop(x, c(2, 5, 8), labels = c(\"Lowest\", \"Low\", \"Higher\", \"Highest\")) data.frame(x, chopped) #>           x chopped #> 1  4.978305     Low #> 2  8.969989 Highest #> 3  3.391823     Low #> 4  4.676785     Low #> 5  7.057042  Higher #> 6  9.707687 Highest #> 7  6.713807  Higher #> 8  8.376589 Highest #> 9  1.086165  Lowest #> 10 4.495479     Low chopped <- chop(x, c(2, 5, 8), lbl_dash()) data.frame(x, chopped) #>           x chopped #> 1  4.978305     2—5 #> 2  8.969989 8—9.708 #> 3  3.391823     2—5 #> 4  4.676785     2—5 #> 5  7.057042     5—8 #> 6  9.707687 8—9.708 #> 7  6.713807     5—8 #> 8  8.376589 8—9.708 #> 9  1.086165 1.086—2 #> 10 4.495479     2—5 chopped <- chop(x, c(2, 5, 8), lbl_dash(first = \"< 2\", last = \"9+\")) data.frame(x, chopped) #>           x chopped #> 1  4.978305     2—5 #> 2  8.969989      9+ #> 3  3.391823     2—5 #> 4  4.676785     2—5 #> 5  7.057042     5—8 #> 6  9.707687      9+ #> 7  6.713807     5—8 #> 8  8.376589      9+ #> 9  1.086165     < 2 #> 10 4.495479     2—5 chopped <- chop(x, c(2, 5, 8), lbl_seq()) data.frame(x, chopped) #>           x chopped #> 1  4.978305       b #> 2  8.969989       d #> 3  3.391823       b #> 4  4.676785       b #> 5  7.057042       c #> 6  9.707687       d #> 7  6.713807       c #> 8  8.376589       d #> 9  1.086165       a #> 10 4.495479       b chop(x, c(2, 5, 8), lbl_seq(\"(1)\")) #>  [1] (2) (4) (2) (2) (3) (4) (3) (4) (1) (2) #> Levels: (1) (2) (3) (4) chop(x, c(2, 5, 8), lbl_seq(\"i.\")) #>  [1] ii.  iv.  ii.  ii.  iii. iv.  iii. iv.  i.   ii.  #> Levels: i. ii. iii. iv. chopped <- chop(x, c(3, 5, 7), extend = FALSE) data.frame(x, chopped) #>           x chopped #> 1  4.978305  [3, 5) #> 2  8.969989    <NA> #> 3  3.391823  [3, 5) #> 4  4.676785  [3, 5) #> 5  7.057042    <NA> #> 6  9.707687    <NA> #> 7  6.713807  [5, 7) #> 8  8.376589    <NA> #> 9  1.086165    <NA> #> 10 4.495479  [3, 5) y <- 1:5 data.frame(         y = y,          left_closed = chop(y, 1:5),          right_closed = chop(y, 1:5, left = FALSE)       ) #>   y left_closed right_closed #> 1 1      [1, 2)          {1} #> 2 2      [2, 3)       (1, 2] #> 3 3      [3, 4)       (2, 3] #> 4 4      [4, 5)       (3, 4] #> 5 5         {5}       (4, 5] data.frame(   y = y,   rightmost_open = chop(y, 1:5),   rightmost_closed   = chop(y, 1:5, close_end = TRUE) ) #>   y rightmost_open rightmost_closed #> 1 1         [1, 2)           [1, 2) #> 2 2         [2, 3)           [2, 3) #> 3 3         [3, 4)           [3, 4) #> 4 4         [4, 5)           [4, 5] #> 5 5            {5}           [4, 5]"},{"path":"/articles/website-articles/performance.html","id":"speed","dir":"Articles > Website-articles","previous_headings":"","what":"Speed","title":"Performance","text":"core santoku written C++. reasonably fast:","code":"packageVersion(\"santoku\") #> [1] '0.6.0.9000' mb <- microbenchmark::microbenchmark(         santoku::chop(rnorm(1e5), -2:2),                   cut(rnorm(1e5), -2:2),           Hmisc::cut2(rnorm(1e5), -2:2)       ) mb #> Unit: milliseconds #>                               expr      min       lq     mean   median       uq #>  santoku::chop(rnorm(1e+05), -2:2) 16.87009 19.93291 28.05275 22.47545 28.94458 #>            cut(rnorm(1e+05), -2:2) 10.65231 12.49209 16.60328 13.43981 18.04926 #>    Hmisc::cut2(rnorm(1e+05), -2:2) 32.10550 38.66206 63.48575 41.79065 48.10011 #>         max neval #>   224.85813   100 #>    47.59338   100 #>  1141.62026   100 ggplot2::autoplot(mb) + ggplot2::theme_light() #> Coordinate system already present. Adding new coordinate system, which will replace the existing one."},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"David Hugh-Jones. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Hugh-Jones D (2021). santoku: Versatile Cutting Tool. https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/.","code":"@Manual{,   title = {santoku: A Versatile Cutting Tool},   author = {David Hugh-Jones},   year = {2021},   note = {https://github.com/hughjonesd/santoku, https://hughjonesd.github.io/santoku/}, }"},{"path":"/index.html","id":"santoku-","dir":"","previous_headings":"","what":"A Versatile Cutting Tool","title":"A Versatile Cutting Tool","text":"santoku versatile cutting tool R. provides chop(), replacement base::cut().","code":""},{"path":"/index.html","id":"advantages","dir":"","previous_headings":"","what":"Advantages","title":"A Versatile Cutting Tool","text":"advantages santoku: default, chop() always covers whole range data, won’t get unexpected NA values. chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. Flexible labelling, including easy ways label intervals numerals letters. Convenience functions creating quantile intervals, evenly-spaced intervals equal-sized groups. Convenience functions quickly tabulating chopped data. advantages make santoku especially useful exploratory analysis, may know range data advance.","code":""},{"path":"/index.html","id":"usage","dir":"","previous_headings":"","what":"Usage","title":"A Versatile Cutting Tool","text":"information, see vignette.","code":"library(santoku)  # chop returns a factor: chop(1:10, c(3, 5, 7)) #>  [1] [1, 3)  [1, 3)  [3, 5)  [3, 5)  [5, 7)  [5, 7)  [7, 10] [7, 10] [7, 10] #> [10] [7, 10] #> Levels: [1, 3) [3, 5) [5, 7) [7, 10]  # Include a number twice to match it exactly; # Use `labels = lbl_discrete()` for integer data: chop(1:10, c(3, 5, 5, 7), labels = lbl_discrete()) #>  [1] 1 - 2  1 - 2  3 - 4  3 - 4  5      6      7 - 10 7 - 10 7 - 10 7 - 10 #> Levels: 1 - 2 3 - 4 5 6 7 - 10  loadNamespace(\"lubridate\") #> <environment: namespace:lubridate>  # chop dates by calendar month, then tabulate: tab_width(as.Date(\"2021-12-31\") + 1:90,              months(1),              labels = lbl_discrete(fmt = \"%d %b\")           ) #> x #> 01 Jan - 31 Jan 01 Feb - 28 Feb 01 Mar - 31 Mar  #>              31              28              31"},{"path":"/reference/breaks-class.html","id":null,"dir":"Reference","previous_headings":"","what":"Class representing a set of intervals — breaks-class","title":"Class representing a set of intervals — breaks-class","text":"Class representing set intervals","code":""},{"path":"/reference/breaks-class.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Class representing a set of intervals — breaks-class","text":"","code":"# S3 method for breaks format(x, ...)  # S3 method for breaks print(x, ...)  is.breaks(x, ...)"},{"path":"/reference/breaks-class.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Class representing a set of intervals — breaks-class","text":"x breaks object ... Unused","code":""},{"path":[]},{"path":"/reference/brk-left-right.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"brk_left(breaks)  brk_right(breaks)"},{"path":"/reference/brk-left-right.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Left- or right-closed breaks — brk-left-right","text":"breaks numeric vector.","code":""},{"path":"/reference/brk-left-right.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Left- or right-closed breaks — brk-left-right","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk-left-right.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Left- or right-closed breaks — brk-left-right","text":"functions \"questioning\" stage clash left argument chop() friends. functions override left argument chop().","code":""},{"path":"/reference/brk-left-right.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Left- or right-closed breaks — brk-left-right","text":"","code":"chop(5:7, brk_left(5:7)) #> Warning: `brk_left()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}  chop(5:7, brk_right(5:7)) #> Warning: `brk_right()` was deprecated in santoku 0.4.0. #> Please use the `left` argument to `chop()` instead. #> This warning is displayed once every 8 hours. #> Call `lifecycle::last_lifecycle_warnings()` to see where this warning was generated. #> Warning: `left` argument to `brk_right()` ignored #> [1] {5}    (5, 6] (6, 7] #> Levels: {5} (5, 6] (6, 7]  chop(5:7, brk_left(5:7)) #> [1] [5, 6) [6, 7) {7}    #> Levels: [5, 6) [6, 7) {7}"},{"path":"/reference/brk_default.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a standard set of breaks — brk_default","title":"Create a standard set of breaks — brk_default","text":"Create standard set breaks","code":""},{"path":"/reference/brk_default.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a standard set of breaks — brk_default","text":"","code":"brk_default(breaks)"},{"path":"/reference/brk_default.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a standard set of breaks — brk_default","text":"breaks numeric vector.","code":""},{"path":"/reference/brk_default.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a standard set of breaks — brk_default","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk_default.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a standard set of breaks — brk_default","text":"","code":"chop(1:10, c(2, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10] chop(1:10, brk_default(c(2, 5, 8))) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10]"},{"path":"/reference/brk_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Create a breaks object manually — brk_manual","title":"Create a breaks object manually — brk_manual","text":"Create breaks object manually","code":""},{"path":"/reference/brk_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create a breaks object manually — brk_manual","text":"","code":"brk_manual(breaks, left_vec)"},{"path":"/reference/brk_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create a breaks object manually — brk_manual","text":"breaks vector, must sorted. left_vec logical vector, length breaks. Specifies whether break left-closed right-closed.","code":""},{"path":"/reference/brk_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create a breaks object manually — brk_manual","text":"(function returns ) object class breaks.","code":""},{"path":"/reference/brk_manual.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Create a breaks object manually — brk_manual","text":"breaks must closed exactly one side, like ..., x) [x, ... (left-closed) ..., x) [x, ... (right-closed). example, breaks = 1:3 left = c(TRUE, FALSE, TRUE), resulting intervals Singleton breaks created repeating number breaks. Singletons must closed sides, repeated number indices , +1, left[] must TRUE left[+1] must FALSE.","code":"T        F       T [ 1,  2 ] ( 2, 3 )"},{"path":"/reference/brk_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create a breaks object manually — brk_manual","text":"","code":"lbrks <- brk_manual(1:3, rep(TRUE, 3)) chop(1:3, lbrks, extend = FALSE) #> [1] [1, 2) [2, 3) <NA>   #> Levels: [1, 2) [2, 3)  rbrks <- brk_manual(1:3, rep(FALSE, 3)) chop(1:3, rbrks, extend = FALSE) #> [1] <NA>   (1, 2] (2, 3] #> Levels: (1, 2] (2, 3]  brks_singleton <- brk_manual(       c(1,    2,    2,     3),       c(TRUE, TRUE, FALSE, TRUE))  chop(1:3, brks_singleton, extend = FALSE) #> [1] [1, 2) {2}    <NA>   #> Levels: [1, 2) {2}"},{"path":"/reference/brk_width-for-datetime.html","id":null,"dir":"Reference","previous_headings":"","what":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"brk_width can used time interval classes base R lubridate package.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"# S3 method for Duration brk_width(width, start)"},{"path":"/reference/brk_width-for-datetime.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width scalar difftime, Period Duration object. start scalar class Date POSIXct. Can omitted.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"width Period, lubridate::add_with_rollback() used calculate widths. can useful e.g. calendar months.","code":""},{"path":"/reference/brk_width-for-datetime.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Equal-width intervals for dates or datetimes — brk_width-for-datetime","text":"","code":"if (requireNamespace(\"lubridate\")) {   year2001 <- as.Date(\"2001-01-01\") + 0:364   tab_width(year2001, months(1),         labels = lbl_discrete(\" to \", fmt = \"%e %b %y\")) } #> Loading required namespace: lubridate #> x #>  1 Jan 01 to 31 Jan 01  1 Feb 01 to 28 Feb 01  1 Mar 01 to 31 Mar 01  #>                     31                     28                     31  #>  1 Apr 01 to 30 Apr 01  1 May 01 to 31 May 01  1 Jun 01 to 30 Jun 01  #>                     30                     31                     30  #>  1 Jul 01 to 31 Jul 01  1 Aug 01 to 31 Aug 01  1 Sep 01 to 30 Sep 01  #>                     31                     31                     30  #>  1 Oct 01 to 31 Oct 01  1 Nov 01 to 30 Nov 01  1 Dec 01 to 31 Dec 01  #>                     31                     30                     31"},{"path":"/reference/chop.html","id":null,"dir":"Reference","previous_headings":"","what":"Cut data into intervals — chop","title":"Cut data into intervals — chop","text":"chop cuts x intervals. returns factor length x, representing interval contains element x.","code":""},{"path":"/reference/chop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Cut data into intervals — chop","text":"","code":"chop(   x,   breaks,   labels,   extend = NULL,   left = TRUE,   close_end = FALSE,   drop = TRUE )  kiru(   x,   breaks,   labels,   extend = NULL,   left = TRUE,   close_end = FALSE,   drop = TRUE )"},{"path":"/reference/chop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Cut data into intervals — chop","text":"x vector. breaks See . labels See . extend Logical. Extend breaks +/-Inf? left Logical. Left-closed breaks? close_end Logical. Close last break right? (left FALSE, close first break left?) drop Logical. Drop unused levels result?","code":""},{"path":"/reference/chop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Cut data into intervals — chop","text":"factor length x, representing intervals containing value x.","code":""},{"path":"/reference/chop.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Cut data into intervals — chop","text":"x may numeric, Date Date-Time.","code":""},{"path":"/reference/chop.html","id":"breaks","dir":"Reference","previous_headings":"","what":"Breaks","title":"Cut data into intervals — chop","text":"breaks may numeric vector function. vector, breaks gives break endpoints. Repeated values create singleton intervals. example breaks = c(1, 3, 3, 5) creates 3 intervals: [1, 3), {3} (3, 5]. breaks function called x, extend, left close_end arguments, return object class breaks. Use brk_ functions context, create variety data-dependent breaks.","code":""},{"path":"/reference/chop.html","id":"options-for-breaks","dir":"Reference","previous_headings":"","what":"Options for breaks","title":"Cut data into intervals — chop","text":"default, left-closed intervals created. left FALSE, right- closed intervals created. close_end TRUE end break closed ends, ensuring values y min(x) <= y <= max(x) included default intervals. Overall: left TRUE close_end TRUE, breaks look like [x1, x2), [x2, x3) ... [x_n-1, x_n]. left FALSE close_end TRUE, breaks look like [x1, x2], (x2, x3] ... (x_n-1, x_n]. left TRUE close_end FALSE, breaks look like ...[x1, x2) .... left FALSE close_end FALSE, breaks look like ...(x1, x2] ....","code":""},{"path":"/reference/chop.html","id":"extending-intervals","dir":"Reference","previous_headings":"","what":"Extending intervals","title":"Cut data into intervals — chop","text":"extend TRUE, intervals extended [-Inf, min(breaks)) (max(breaks), Inf]. extend NULL (default), intervals extended [min(x), min(breaks)) (max(breaks), max(x)], necessary -- .e. min(x) < min(breaks) max(x) > max(breaks) respectively. Extending intervals, either extend = NULL extend = FALSE, always leaves central, non-extended intervals unchanged. particular, close_end applies central intervals, extended ones. example, breaks = c(1, 3, 5) close_end = TRUE, resulting breaks [1, 3), [3, 5] extend = TRUE result [-Inf, 1), [1, 3), [3, 5], (5, Inf]","code":""},{"path":"/reference/chop.html","id":"labels","dir":"Reference","previous_headings":"","what":"Labels","title":"Cut data into intervals — chop","text":"labels may character vector. length number intervals. Alternatively, use lbl_ function lbl_seq().","code":""},{"path":"/reference/chop.html","id":"miscellaneous","dir":"Reference","previous_headings":"","what":"Miscellaneous","title":"Cut data into intervals — chop","text":"NA values x, values outside extended endpoints, return NA. kiru synonym chop. load tidyr, can use avoid confusion tidyr::chop(). Note chop, like R, uses binary arithmetic. Thus, numbers may exactly equal think . example .","code":""},{"path":[]},{"path":"/reference/chop.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Cut data into intervals — chop","text":"","code":"chop(1:3, 2) #> [1] [1, 2) [2, 3] [2, 3] #> Levels: [1, 2) [2, 3]  chop(1:10, c(2, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8)  [5, 8)  [5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) [5, 8) [8, 10]  chop(1:10, c(2, 5, 8), extend = FALSE) #>  [1] <NA>   [2, 5) [2, 5) [2, 5) [5, 8) [5, 8) [5, 8) <NA>   <NA>   <NA>   #> Levels: [2, 5) [5, 8)  chop(1:10, c(2, 5, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]  chop(1:10, c(2, 5, 8), left = FALSE) #>  [1] [1, 2]  [1, 2]  (2, 5]  (2, 5]  (2, 5]  (5, 8]  (5, 8]  (5, 8]  (8, 10] #> [10] (8, 10] #> Levels: [1, 2] (2, 5] (5, 8] (8, 10]  chop(1:10, c(2, 5, 8), close_end = TRUE) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  [5, 8]  [5, 8]  [5, 8]  [5, 8]  (8, 10] #> [10] (8, 10] #> Levels: [1, 2) [2, 5) [5, 8] (8, 10]  chop(1:10, brk_quantiles(c(0.25, 0.75))) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 75%)  [25%, 75%)  [25%, 75%)  #>  [7] [25%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 75%) [75%, 100%]  chop(1:10, c(2, 5, 8), labels = lbl_dash()) #>  [1] 1—2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: 1—2 2—5 5—8 8—10  # floating point inaccuracy: chop(0.3/3, c(0, 0.1, 0.1, 1), labels = c(\"< 0.1\", \"0.1\", \"> 0.1\")) #> [1] < 0.1 #> Levels: < 0.1"},{"path":"/reference/chop_mean_sd.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by standard deviations — chop_mean_sd","title":"Chop by standard deviations — chop_mean_sd","text":"Intervals width 1 standard deviation included either side mean. outermost pair intervals shorter sd whole number.","code":""},{"path":"/reference/chop_mean_sd.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(x, sd = 3, ...)  brk_mean_sd(sd = 3)"},{"path":"/reference/chop_mean_sd.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by standard deviations — chop_mean_sd","text":"x vector. sd Positive number: include sd standard deviations. ... Passed chop().","code":""},{"path":"/reference/chop_mean_sd.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by standard deviations — chop_mean_sd","text":" chop_* functions, factor length x.","code":""},{"path":[]},{"path":"/reference/chop_mean_sd.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by standard deviations — chop_mean_sd","text":"","code":"chop_mean_sd(1:10) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)  chop(1:10, brk_mean_sd()) #>  [1] [-2 sd, -1 sd) [-2 sd, -1 sd) [-1 sd, 0 sd)  [-1 sd, 0 sd)  [-1 sd, 0 sd)  #>  [6] [0 sd, 1 sd)   [0 sd, 1 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)   [1 sd, 2 sd)   #> Levels: [-2 sd, -1 sd) [-1 sd, 0 sd) [0 sd, 1 sd) [1 sd, 2 sd)"},{"path":"/reference/chop_n.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into fixed-sized groups — chop_n","title":"Chop into fixed-sized groups — chop_n","text":"chop_n() creates intervals containing fixed number elements. One interval may fewer elements.","code":""},{"path":"/reference/chop_n.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into fixed-sized groups — chop_n","text":"","code":"chop_n(x, n, ..., close_end = TRUE)  brk_n(n)"},{"path":"/reference/chop_n.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into fixed-sized groups — chop_n","text":"x vector. n Integer: number elements interval. ... Passed chop(). close_end Passed chop().","code":""},{"path":"/reference/chop_n.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into fixed-sized groups — chop_n","text":" chop_* functions, factor length x.","code":""},{"path":"/reference/chop_n.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into fixed-sized groups — chop_n","text":"Note chop_n() sets close_end = TRUE default. Groups may larger n, many duplicated elements x. , warning given.","code":""},{"path":[]},{"path":"/reference/chop_n.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into fixed-sized groups — chop_n","text":"","code":"table(chop_n(1:10, 5)) #>  #>  [1, 6) [6, 10]  #>       5       5   table(chop_n(1:10, 4)) #>  #>  [1, 5)  [5, 9) [9, 10]  #>       4       4       2   # too many duplicates x <- rep(1:2, each = 3) chop_n(x, 2) #> Warning: Some intervals contain more than 2 elements #> [1] {1} {1} {1} {2} {2} {2} #> Levels: {1} {2}"},{"path":"/reference/chop_quantiles.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop by quantiles — chop_quantiles","title":"Chop by quantiles — chop_quantiles","text":"chop_quantiles chops data quantiles. chop_equally chops data equal-sized groups. chop_deciles convenience shortcut chops deciles.","code":""},{"path":"/reference/chop_quantiles.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(x, probs, ..., left = is.numeric(x), close_end = TRUE)  chop_deciles(x, ...)  chop_equally(x, groups, ..., left = is.numeric(x), close_end = TRUE)  brk_quantiles(probs, ...)  brk_equally(groups)"},{"path":"/reference/chop_quantiles.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop by quantiles — chop_quantiles","text":"x vector. probs vector probabilities quantiles. ... Passed chop(), brk_quantiles stats::quantile(). left Passed chop(). close_end Passed chop(). groups Number groups.","code":""},{"path":"/reference/chop_quantiles.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop by quantiles — chop_quantiles","text":" chop_* functions, factor length x.","code":""},{"path":"/reference/chop_quantiles.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop by quantiles — chop_quantiles","text":"Note functions set close_end = TRUE default. helps ensure e.g. chop_quantiles(x, c(0, 1/3, 2/3, 1) split data three equal-sized groups. non-numeric x, left set FALSE default. works better calculating \"type 1\" quantiles, since round . See stats::quantile().","code":""},{"path":[]},{"path":"/reference/chop_quantiles.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop by quantiles — chop_quantiles","text":"","code":"chop_quantiles(1:10, 1:3/4) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%]  #>  [7] [50%, 75%]  (75%, 100%] (75%, 100%] (75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%] (75%, 100%]  chop(1:10, brk_quantiles(1:3/4)) #>  [1] [0%, 25%)   [0%, 25%)   [0%, 25%)   [25%, 50%)  [25%, 50%)  [50%, 75%)  #>  [7] [50%, 75%)  [75%, 100%] [75%, 100%] [75%, 100%] #> Levels: [0%, 25%) [25%, 50%) [50%, 75%) [75%, 100%]  chop_deciles(1:10) #>  [1] [0%, 10%)   [10%, 20%)  [20%, 30%)  [30%, 40%)  [40%, 50%)  [50%, 60%)  #>  [7] [60%, 70%)  [70%, 80%)  [80%, 90%)  [90%, 100%] #> 10 Levels: [0%, 10%) [10%, 20%) [20%, 30%) [30%, 40%) [40%, 50%) ... [90%, 100%]  chop_equally(1:10, 5) #>  [1] [0%, 20%)   [0%, 20%)   [20%, 40%)  [20%, 40%)  [40%, 60%)  [40%, 60%)  #>  [7] [60%, 80%)  [60%, 80%)  [80%, 100%] [80%, 100%] #> Levels: [0%, 20%) [20%, 40%) [40%, 60%) [60%, 80%) [80%, 100%]  # to label by the quantiles themselves: chop_quantiles(1:10, 1:3/4, lbl_intervals(raw = TRUE)) #>  [1] [1, 3.25)   [1, 3.25)   [1, 3.25)   [3.25, 5.5) [3.25, 5.5) [5.5, 7.75] #>  [7] [5.5, 7.75] (7.75, 10]  (7.75, 10]  (7.75, 10]  #> Levels: [1, 3.25) [3.25, 5.5) [5.5, 7.75] (7.75, 10]"},{"path":"/reference/chop_width.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop into equal-width intervals — chop_width","title":"Chop into equal-width intervals — chop_width","text":"chop_width() chops x intervals width width. chop_evenly chops x intervals intervals equal width.","code":""},{"path":"/reference/chop_width.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop into equal-width intervals — chop_width","text":"","code":"chop_width(x, width, start, ..., left = width > 0)  chop_evenly(x, intervals, ..., groups, close_end = TRUE)  brk_width(width, start)  # S3 method for default brk_width(width, start)  brk_evenly(intervals)"},{"path":"/reference/chop_width.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop into equal-width intervals — chop_width","text":"x vector. width Width intervals. start Leftpoint first interval. default smallest finite x, width negative, largest finite x. ... Passed chop(). left Passed chop(). intervals Integer: number intervals create. groups use. close_end Passed chop().","code":""},{"path":"/reference/chop_width.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop into equal-width intervals — chop_width","text":" chop_* functions, factor length x.","code":""},{"path":"/reference/chop_width.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop into equal-width intervals — chop_width","text":"width negative, intervals go downwards start. chop_evenly sets close_end = TRUE default. chop_width sets left = FALSE width negative.","code":""},{"path":[]},{"path":"/reference/chop_width.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop into equal-width intervals — chop_width","text":"","code":"chop_width(1:10, 2) #>  [1] [1, 3)  [1, 3)  [3, 5)  [3, 5)  [5, 7)  [5, 7)  [7, 9)  [7, 9)  [9, 11) #> [10] [9, 11) #> Levels: [1, 3) [3, 5) [5, 7) [7, 9) [9, 11)  chop_width(1:10, 2, start = 0) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10) [8, 10) #> [10] {10}    #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10) {10}  chop_width(1:9, -2) #> [1] {1}    (1, 3] (1, 3] (3, 5] (3, 5] (5, 7] (5, 7] (7, 9] (7, 9] #> Levels: {1} (1, 3] (3, 5] (5, 7] (7, 9]  chop(1:10, brk_width(2, 0)) #>  [1] [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10) [8, 10) #> [10] {10}    #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10) {10}  chop_evenly(0:10, 5) #>  [1] [0, 2)  [0, 2)  [2, 4)  [2, 4)  [4, 6)  [4, 6)  [6, 8)  [6, 8)  [8, 10] #> [10] [8, 10] [8, 10] #> Levels: [0, 2) [2, 4) [4, 6) [6, 8) [8, 10]"},{"path":"/reference/exactly.html","id":null,"dir":"Reference","previous_headings":"","what":"Syntactic sugar — exactly","title":"Syntactic sugar — exactly","text":"exactly lets write chop(x, c(1, exactly(2), 3)). chop(x, c(1, 2, 2, 3)) conveys intent clearly.","code":""},{"path":"/reference/exactly.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Syntactic sugar — exactly","text":"","code":"exactly(x)"},{"path":"/reference/exactly.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Syntactic sugar — exactly","text":"x numeric vector.","code":""},{"path":"/reference/exactly.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Syntactic sugar — exactly","text":"rep(x, = 2).","code":""},{"path":"/reference/exactly.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Syntactic sugar — exactly","text":"","code":"chop(1:10, c(2, exactly(5), 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]  # same: chop(1:10, c(2, 5, 5, 8)) #>  [1] [1, 2)  [2, 5)  [2, 5)  [2, 5)  {5}     (5, 8)  (5, 8)  [8, 10] [8, 10] #> [10] [8, 10] #> Levels: [1, 2) [2, 5) {5} (5, 8) [8, 10]"},{"path":"/reference/fillet.html","id":null,"dir":"Reference","previous_headings":"","what":"Chop data precisely (for programmers) — fillet","title":"Chop data precisely (for programmers) — fillet","text":"Chop data precisely (programmers)","code":""},{"path":"/reference/fillet.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(x, breaks, labels, left = TRUE, close_end = FALSE)"},{"path":"/reference/fillet.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Chop data precisely (for programmers) — fillet","text":"x vector. breaks Passed chop(). labels Passed chop(). left Passed chop(). close_end Passed chop().","code":""},{"path":"/reference/fillet.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Chop data precisely (for programmers) — fillet","text":" chop_* functions, factor length x.","code":""},{"path":"/reference/fillet.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Chop data precisely (for programmers) — fillet","text":"fillet() calls chop() extend = FALSE drop = FALSE. ensures get breaks labels ask . programming, consider using fillet() instead chop().","code":""},{"path":[]},{"path":"/reference/fillet.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Chop data precisely (for programmers) — fillet","text":"","code":"fillet(1:10, c(2, 5, 8)) #>  [1] <NA>   [2, 5) [2, 5) [2, 5) [5, 8) [5, 8) [5, 8) <NA>   <NA>   <NA>   #> Levels: [2, 5) [5, 8)"},{"path":"/reference/knife.html","id":null,"dir":"Reference","previous_headings":"","what":"Deprecated — knife","title":"Deprecated — knife","text":"knife() deprecated favour purrr::partial().","code":""},{"path":"/reference/knife.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Deprecated — knife","text":"","code":"knife(...)"},{"path":"/reference/knife.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Deprecated — knife","text":"... Parameters chop().","code":""},{"path":"/reference/knife.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Deprecated — knife","text":"function.","code":""},{"path":"/reference/lbl_dash.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"label style user-friendly, distinguish left- right-closed intervals.","code":""},{"path":"/reference/lbl_dash.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"","code":"lbl_dash(symbol = \"—\", raw = FALSE, fmt = NULL, first = NULL, last = NULL)"},{"path":"/reference/lbl_dash.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"symbol String: symbol use dash. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. first String: override label first category. last String: override label last category.","code":""},{"path":"/reference/lbl_dash.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_dash.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"terminal support unicode, use lbl_dash(\"-\").","code":""},{"path":[]},{"path":"/reference/lbl_dash.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals like 1-3, 4-5, ... — lbl_dash","text":"","code":"chop(1:10, c(2, 5, 8), lbl_dash()) #>  [1] 1—2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: 1—2 2—5 5—8 8—10  chop(1:10, c(2, 5, 8), lbl_dash(\" to \", fmt = \"%.1f\")) #>  [1] 1.0 to 2.0  2.0 to 5.0  2.0 to 5.0  2.0 to 5.0  5.0 to 8.0  5.0 to 8.0  #>  [7] 5.0 to 8.0  8.0 to 10.0 8.0 to 10.0 8.0 to 10.0 #> Levels: 1.0 to 2.0 2.0 to 5.0 5.0 to 8.0 8.0 to 10.0  chop(1:10, c(2, 5, 8), lbl_dash(first = \"< %s\")) #>  [1] < 2  2—5  2—5  2—5  5—8  5—8  5—8  8—10 8—10 8—10 #> Levels: < 2 2—5 5—8 8—10  pretty <- function (x) prettyNum(x, big.mark = \",\", digits = 1) chop(runif(10) * 10000, c(3000, 7000), lbl_dash(\" to \", fmt = pretty)) #>  [1] 3,000 to 7,000 3,000 to 7,000 58 to 3,000    7,000 to 7,158 3,000 to 7,000 #>  [6] 58 to 3,000    58 to 3,000    3,000 to 7,000 3,000 to 7,000 58 to 3,000    #> Levels: 58 to 3,000 3,000 to 7,000 7,000 to 7,158"},{"path":[]},{"path":"/reference/lbl_discrete.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label discrete data — lbl_discrete","text":"","code":"lbl_discrete(symbol = \"—\", fmt = NULL, first = NULL, last = NULL)"},{"path":"/reference/lbl_discrete.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label discrete data — lbl_discrete","text":"symbol String: symbol use dash. fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. first String: override label first category. last String: override label last category.","code":""},{"path":"/reference/lbl_discrete.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label discrete data — lbl_discrete","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_discrete.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label discrete data — lbl_discrete","text":"lbl_discrete creates labels discrete data integers. example, breaks c(1, 3, 4, 6, 7) labelled: \"1 - 2\", \"3\", \"4 - 5\", \"6 - 7\". check done data discrete-valued. , labels may misleading. , discrete-valued means x < y, x <= y - 1. aware Date objects may non-integer values. See Date.","code":""},{"path":[]},{"path":"/reference/lbl_discrete.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label discrete data — lbl_discrete","text":"","code":"tab(1:7, c(1, 3, 5), lbl_discrete()) #> x #> 1—2 3—4 5—7  #>   2   2   3   tab(1:7, c(3, 5), lbl_discrete(first = \"<= %s\")) #> x #> <= 2  3—4  5—7  #>    2    2    3   # Misleading labels for non-integer data chop(2.5, c(1, 3, 5), lbl_discrete()) #> [1] 1—2 #> Levels: 1—2"},{"path":"/reference/lbl_endpoint.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals by their left or right endpoints — lbl_endpoint","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"useful left endpoint unambiguously indicates interval. cases may give errors due duplicate labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"lbl_endpoint(fmt = NULL, raw = FALSE, left = TRUE)"},{"path":"/reference/lbl_endpoint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? left Flag. Use left endpoint right endpoint?","code":""},{"path":"/reference/lbl_endpoint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_endpoint.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals by their left or right endpoints — lbl_endpoint","text":"","code":"chop(1:10, c(2, 5, 8), lbl_endpoint(left = TRUE)) #>  [1] 1 2 2 2 5 5 5 8 8 8 #> Levels: 1 2 5 8 chop(1:10, c(2, 5, 8), lbl_endpoint(left = FALSE)) #>  [1] 2  5  5  5  8  8  8  10 10 10 #> Levels: 2 5 8 10 if (requireNamespace(\"lubridate\")) {   tab_width(           as.Date(\"2000-01-01\") + 0:365,          months(1),          labels = lbl_endpoint(fmt = \"%b\")        ) } #> x #> Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec  #>  31  29  31  30  31  30  31  31  30  31  30  31"},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"lbl_format(fmt, fmt1 = \"%.3g\", raw = FALSE)"},{"path":"/reference/lbl_format.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function. fmt1 Format breaks consisting single value. raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations?","code":""},{"path":"/reference/lbl_format.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_format.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"labels let format breaks arbitrarily, using either string (passed sprintf()) function. fmt function, must accept two arguments, representing left right endpoints interval. breaks non-numeric, can use \"%s\" string fmt. breaks converted character case. lbl_format() \"questioning\" stage. alternative, consider using lbl_dash() lbl_intervals() fmt argument.","code":""},{"path":[]},{"path":"/reference/lbl_format.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals with arbitrary formatting — lbl_format","text":"","code":"tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\")) #> x #>  1 to 3       3  3 to 7 7 to 10  #>       2       1       3       4  tab(1:10, c(1,3, 3, 7),       label = lbl_format(\"%.3g to %.3g\", \"Exactly %.3g\")) #> x #>    1 to 3 Exactly 3    3 to 7   7 to 10  #>         2         1         3         4   percent2 <- function (x, y) {   sprintf(\"%.2f%% - %.2f%%\", x*100, y*100) } tab(runif(100), c(0.25, 0.5, .75),       labels = lbl_format(percent2)) #> x #>  0.30% - 25.00% 25.00% - 50.00% 50.00% - 75.00% 75.00% - 99.72%  #>              23              29              19              29"},{"path":"/reference/lbl_intervals.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals using set notation — lbl_intervals","title":"Label chopped intervals using set notation — lbl_intervals","text":"Label chopped intervals using set notation","code":""},{"path":"/reference/lbl_intervals.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"lbl_intervals(raw = FALSE, fmt = NULL)"},{"path":"/reference/lbl_intervals.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals using set notation — lbl_intervals","text":"raw Logical. Always use raw breaks labels, rather e.g. quantiles standard deviations? fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function.","code":""},{"path":"/reference/lbl_intervals.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals using set notation — lbl_intervals","text":"vector labels chop, function creates labels.","code":""},{"path":"/reference/lbl_intervals.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals using set notation — lbl_intervals","text":"Mathematical set notation follows: [, b]: numbers x <= x <= b; (, b): numbers < x < b; [, b): numbers <= x < b; (, b]: numbers < x <= b; {}: just number .","code":""},{"path":[]},{"path":"/reference/lbl_intervals.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals using set notation — lbl_intervals","text":"","code":"tab(-10:10, c(-3, 0, 0, 3),       labels = lbl_intervals()) #> x #> [-10, -3)   [-3, 0)       {0}    (0, 3)   [3, 10]  #>         7         3         1         2         8   tab_evenly(runif(20), 10,       labels = lbl_intervals(fmt = percent)) #> x #> [4.525%, 13.42%) [13.42%, 22.32%) [22.32%, 31.21%) [31.21%, 40.11%)  #>                4                4                1                1  #>  [49.01%, 57.9%)   [57.9%, 66.8%)   [66.8%, 75.7%)  [75.7%, 84.59%)  #>                1                2                2                2  #> [84.59%, 93.49%]  #>                3"},{"path":"/reference/lbl_manual.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals in a user-defined sequence — lbl_manual","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"lbl_manual() uses arbitrary sequence label intervals. sequence short, pasted repeated.","code":""},{"path":"/reference/lbl_manual.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"lbl_manual(sequence, fmt = \"%s\")"},{"path":"/reference/lbl_manual.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"sequence character vector labels. fmt format. Can string, passed base::sprintf() format() methods; one-argument formatting function.","code":""},{"path":"/reference/lbl_manual.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"vector labels chop, function creates labels.","code":""},{"path":[]},{"path":"/reference/lbl_manual.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in a user-defined sequence — lbl_manual","text":"","code":"chop(1:10, c(2, 5, 8), lbl_manual(c(\"w\", \"x\", \"y\", \"z\"))) #>  [1] w x x x y y y z z z #> Levels: w x y z  # if labels need repeating: chop(1:10, 1:10, lbl_manual(c(\"x\", \"y\", \"z\"))) #>  [1] x    y    z    xx   yy   zz   xxx  yyy  zzz  xxxx #> Levels: x y z xx yy zz xxx yyy zzz xxxx"},{"path":"/reference/lbl_seq.html","id":null,"dir":"Reference","previous_headings":"","what":"Label chopped intervals in sequence — lbl_seq","title":"Label chopped intervals in sequence — lbl_seq","text":"lbl_seq labels intervals sequentially, using numbers letters.","code":""},{"path":"/reference/lbl_seq.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"lbl_seq(start = \"a\")"},{"path":"/reference/lbl_seq.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Label chopped intervals in sequence — lbl_seq","text":"start String. template sequence. See .","code":""},{"path":"/reference/lbl_seq.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Label chopped intervals in sequence — lbl_seq","text":"start shows first element sequence. must contain exactly one character set \"\", \"\", \"\", \"\" \"1\". later elements: \"\" replaced \"\", \"b\", \"c\", ... \"\" replaced \"\", \"B\", \"C\", ... \"\" replaced lower-case Roman numerals \"\", \"ii\", \"iii\", ... \"\" replaced upper-case Roman numerals \"\", \"II\", \"III\", ... \"1\" replaced numbers \"1\", \"2\", \"3\", ... characters retained -.","code":""},{"path":[]},{"path":"/reference/lbl_seq.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Label chopped intervals in sequence — lbl_seq","text":"","code":"chop(1:10, c(2, 5, 8), lbl_seq()) #>  [1] a b b b c c c d d d #> Levels: a b c d  chop(1:10, c(2, 5, 8), lbl_seq(\"i.\")) #>  [1] i.   ii.  ii.  ii.  iii. iii. iii. iv.  iv.  iv.  #> Levels: i. ii. iii. iv.  chop(1:10, c(2, 5, 8), lbl_seq(\"(A)\")) #>  [1] (A) (B) (B) (B) (C) (C) (C) (D) (D) (D) #> Levels: (A) (B) (C) (D)"},{"path":"/reference/percent.html","id":null,"dir":"Reference","previous_headings":"","what":"Simple formatter — percent","title":"Simple formatter — percent","text":"wider range formatters, consider \"scales\" package.","code":""},{"path":"/reference/percent.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Simple formatter — percent","text":"","code":"percent(x)"},{"path":"/reference/percent.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Simple formatter — percent","text":"x Numeric values.","code":""},{"path":"/reference/percent.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Simple formatter — percent","text":"x formatted percent.","code":""},{"path":"/reference/percent.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Simple formatter — percent","text":"","code":"percent(0.5) #> [1] \"50%\""},{"path":"/reference/santoku-package.html","id":null,"dir":"Reference","previous_headings":"","what":"A versatile cutting tool for R — santoku-package","title":"A versatile cutting tool for R — santoku-package","text":"santoku tool cutting data intervals. provides function chop(), similar base R's cut() Hmisc::cut2(). chop(x, breaks) takes vector x returns factor length, coding interval element x falls .","code":""},{"path":"/reference/santoku-package.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"A versatile cutting tool for R — santoku-package","text":"advantages santoku: default, chop() always covers whole range data, get unexpected NA values. Unlike cut() cut2(), chop() can handle single values well intervals. example, chop(x, breaks = c(1, 2, 2, 3)) create separate factor level values exactly equal 2. Flexible easy labelling. Convenience functions creating quantile intervals, evenly-spaced intervals equal-sized groups. Convenience functions quickly tabulate chopped data. Can chop numbers, dates date-times. advantages make santoku especially useful exploratory analysis, may know range data advance. get started, read vignette:  details, start documentation chop().","code":"vignette(\"santoku\")"},{"path":[]},{"path":"/reference/santoku-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"A versatile cutting tool for R — santoku-package","text":"Maintainer: David Hugh-Jones davidhughjones@gmail.com","code":""},{"path":"/reference/tab.html","id":null,"dir":"Reference","previous_headings":"","what":"Tabulate data by intervals — tab","title":"Tabulate data by intervals — tab","text":"functions call related chop_xxx function, call table() result.","code":""},{"path":"/reference/tab.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Tabulate data by intervals — tab","text":"","code":"tab(...)  tab_width(...)  tab_evenly(...)  tab_n(...)  tab_mean_sd(...)"},{"path":"/reference/tab.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Tabulate data by intervals — tab","text":"... Passed chop","code":""},{"path":"/reference/tab.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Tabulate data by intervals — tab","text":"table().","code":""},{"path":"/reference/tab.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Tabulate data by intervals — tab","text":"","code":"tab(1:10, c(2, 5, 8)) #> x #>  [1, 2)  [2, 5)  [5, 8) [8, 10]  #>       1       3       3       3   tab_mean_sd(1:10) #> x #> [-2 sd, -1 sd)  [-1 sd, 0 sd)   [0 sd, 1 sd)   [1 sd, 2 sd)  #>              2              3              3              2"},{"path":"/news/index.html","id":"santoku-development-version","dir":"Changelog","previous_headings":"","what":"santoku (development version)","title":"santoku (development version)","text":"Bugfix: lbl_endpoint() erroring types breaks. Use unicode em-dash spaces lbl_dash() lbl_discrete().","code":""},{"path":"/news/index.html","id":"santoku-060","dir":"Changelog","previous_headings":"","what":"santoku 0.6.0","title":"santoku 0.6.0","text":"CRAN release: 2021-11-04 New arguments first last lbl_dash() lbl_discrete() allow override first last interval labels. Fixes CRAN.","code":""},{"path":"/news/index.html","id":"santoku-050","dir":"Changelog","previous_headings":"","what":"santoku 0.5.0","title":"santoku 0.5.0","text":"CRAN release: 2020-08-27 sets left = FALSE default. Also works negative time intervals.","code":""},{"path":"/news/index.html","id":"santoku-041","dir":"Changelog","previous_headings":"","what":"santoku 0.4.1","title":"santoku 0.4.1","text":"CRAN release: 2020-06-16 Bugfix: chop(1:4, 1) erroring.","code":""},{"path":"/news/index.html","id":"santoku-040","dir":"Changelog","previous_headings":"","what":"santoku 0.4.0","title":"santoku 0.4.0","text":"CRAN release: 2020-06-09","code":""},{"path":"/news/index.html","id":"interface-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Interface changes","title":"santoku 0.4.0","text":"new version interface changes. based user experience, designed make using chop() intuitive predictable. chop() two new arguments, left close_end. Using left = FALSE simpler intuitive wrapping breaks brk_right(). brk_left() brk_right() kept now, used wrap break functions. Using close_end simpler passing close_end brk_left() brk_right() (longer accept argument directly). left = TRUE default, except non-numeric objects chop_quantiles() chop_equally(), left = FALSE works better. close_end now FALSE default. prevents user surprises e.g. chop(3, 1:3) puts 3 different category chop(3, 1:4). close_end TRUE default chop_quantiles(), chop_n() similar functions. ensures e.g.  chop_quantiles(x, c(0, 1/3, 2/3, 1)) expect. groups argument chop_evenly() renamed groups intervals. make easier remember difference chop_evenly() chop_equally(). (Chop evenly n equal-width intervals, chop equally n equal-sized groups.) knife() deprecated keep interface slim focused. Use purrr::partial() instead.","code":""},{"path":"/news/index.html","id":"other-changes-0-4-0","dir":"Changelog","previous_headings":"","what":"Other changes","title":"santoku 0.4.0","text":"Date datetime (POSIXct) objects can now chopped. chop_width() accepts difftime, lubridate::period lubridate::duration objects chop_ functions work well. Many labelling functions new fmt argument. can string interpreted sprintf() format(), 1-argument formatting function break endpoints, e.g. scales::label_percent(). Experimental: lbl_discrete() discrete data integers () dates. new lbl_endpoint() function labelling intervals solely left right endpoint. brk_mean_sd() now accepts non-integer positive numbers. Add brk_equally() symmetry chop_equally(). Minor tweaks chop_deciles(). Bugfix: lbl_format() wasn’t accepting numeric formats, even raw = TRUE. Thanks Sharla Gelfand.","code":""},{"path":"/news/index.html","id":"santoku-030","dir":"Changelog","previous_headings":"","what":"santoku 0.3.0","title":"santoku 0.3.0","text":"CRAN release: 2020-01-24 First CRAN release. Changed kut() kiru(). kiru() alternative spelling chop(), use tidyr package loaded. lbl_sequence() become lbl_manual(). lbl_letters() friends replaced lbl_seq(): replace lbl_letters() use lbl_seq() replace lbl_LETTERS() use lbl_seq(\"\") replace lbl_roman() use lbl_seq(\"\") replace lbl_ROMAN() use lbl_seq(\"\") replace lbl_numerals() use lbl_seq(\"1\") complex formatting use e.g. lbl_seq(\":\"), lbl_seq(\"()\")","code":""},{"path":"/news/index.html","id":"santoku-020","dir":"Changelog","previous_headings":"","what":"santoku 0.2.0","title":"santoku 0.2.0","text":"Added NEWS.md file track changes package. Default labels extend = NULL changed, [-Inf, ... ..., Inf] [min(x), ... ..., max(x)].","code":""}]
